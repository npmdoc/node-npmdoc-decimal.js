<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/MikeMcl/decimal.js#readme">decimal.js (v7.2.0)</a>
</h1>
<h4>An arbitrary-precision Decimal type for JavaScript.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.decimal.js">module decimal.js</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">decimal.js.</span>crypto</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.js">
            function <span class="apidocSignatureSpan">decimal.</span>js
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal">
            function <span class="apidocSignatureSpan">decimal.js.</span>Decimal
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.abs">
            function <span class="apidocSignatureSpan">decimal.js.</span>abs
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.acos">
            function <span class="apidocSignatureSpan">decimal.js.</span>acos
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.acosh">
            function <span class="apidocSignatureSpan">decimal.js.</span>acosh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.add">
            function <span class="apidocSignatureSpan">decimal.js.</span>add
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.asin">
            function <span class="apidocSignatureSpan">decimal.js.</span>asin
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.asinh">
            function <span class="apidocSignatureSpan">decimal.js.</span>asinh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.atan">
            function <span class="apidocSignatureSpan">decimal.js.</span>atan
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.atan2">
            function <span class="apidocSignatureSpan">decimal.js.</span>atan2
            <span class="apidocSignatureSpan">(y, x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.atanh">
            function <span class="apidocSignatureSpan">decimal.js.</span>atanh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.cbrt">
            function <span class="apidocSignatureSpan">decimal.js.</span>cbrt
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.ceil">
            function <span class="apidocSignatureSpan">decimal.js.</span>ceil
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.clone">
            function <span class="apidocSignatureSpan">decimal.js.</span>clone
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.config">
            function <span class="apidocSignatureSpan">decimal.js.</span>config
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.cos">
            function <span class="apidocSignatureSpan">decimal.js.</span>cos
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.cosh">
            function <span class="apidocSignatureSpan">decimal.js.</span>cosh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.default">
            function <span class="apidocSignatureSpan">decimal.js.</span>default
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.div">
            function <span class="apidocSignatureSpan">decimal.js.</span>div
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.exp">
            function <span class="apidocSignatureSpan">decimal.js.</span>exp
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.floor">
            function <span class="apidocSignatureSpan">decimal.js.</span>floor
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.hypot">
            function <span class="apidocSignatureSpan">decimal.js.</span>hypot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.js.Decimal">
            function <span class="apidocSignatureSpan">decimal.js.</span>js.Decimal
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.ln">
            function <span class="apidocSignatureSpan">decimal.js.</span>ln
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.log">
            function <span class="apidocSignatureSpan">decimal.js.</span>log
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.log10">
            function <span class="apidocSignatureSpan">decimal.js.</span>log10
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.log2">
            function <span class="apidocSignatureSpan">decimal.js.</span>log2
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.max">
            function <span class="apidocSignatureSpan">decimal.js.</span>max
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.min">
            function <span class="apidocSignatureSpan">decimal.js.</span>min
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.mod">
            function <span class="apidocSignatureSpan">decimal.js.</span>mod
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.mul">
            function <span class="apidocSignatureSpan">decimal.js.</span>mul
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.pow">
            function <span class="apidocSignatureSpan">decimal.js.</span>pow
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.random">
            function <span class="apidocSignatureSpan">decimal.js.</span>random
            <span class="apidocSignatureSpan">(sd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.round">
            function <span class="apidocSignatureSpan">decimal.js.</span>round
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.set">
            function <span class="apidocSignatureSpan">decimal.js.</span>set
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.sign">
            function <span class="apidocSignatureSpan">decimal.js.</span>sign
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.sin">
            function <span class="apidocSignatureSpan">decimal.js.</span>sin
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.sinh">
            function <span class="apidocSignatureSpan">decimal.js.</span>sinh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.sqrt">
            function <span class="apidocSignatureSpan">decimal.js.</span>sqrt
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.sub">
            function <span class="apidocSignatureSpan">decimal.js.</span>sub
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.tan">
            function <span class="apidocSignatureSpan">decimal.js.</span>tan
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.tanh">
            function <span class="apidocSignatureSpan">decimal.js.</span>tanh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.trunc">
            function <span class="apidocSignatureSpan">decimal.js.</span>trunc
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>EUCLID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>ROUND_CEIL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>ROUND_DOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>ROUND_FLOOR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>ROUND_HALF_CEIL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>ROUND_HALF_DOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>ROUND_HALF_EVEN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>ROUND_HALF_FLOOR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>ROUND_HALF_UP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>ROUND_UP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>maxE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>minE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>modulo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>precision</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>rounding</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>toExpNeg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.</span>toExpPos</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">decimal.js.</span>js.Decimal.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.decimal.js.Decimal">module decimal.js.Decimal</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">decimal.js.Decimal.</span>crypto</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.Decimal">
            function <span class="apidocSignatureSpan">decimal.js.</span>Decimal
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.abs">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>abs
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.acos">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>acos
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.acosh">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>acosh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.add">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>add
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.asin">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>asin
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.asinh">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>asinh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.atan">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>atan
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.atan2">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>atan2
            <span class="apidocSignatureSpan">(y, x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.atanh">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>atanh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.cbrt">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>cbrt
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.ceil">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>ceil
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.clone">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>clone
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.config">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>config
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.cos">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>cos
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.cosh">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>cosh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.default">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>default
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.div">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>div
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.exp">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>exp
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.floor">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>floor
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.hypot">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>hypot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.ln">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>ln
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.log">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>log
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.log10">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>log10
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.log2">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>log2
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.max">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>max
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.min">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>min
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.mod">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>mod
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.mul">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>mul
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.pow">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>pow
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.random">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>random
            <span class="apidocSignatureSpan">(sd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.round">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>round
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.set">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>set
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.sign">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>sign
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.sin">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>sin
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.sinh">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>sinh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.sqrt">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>sqrt
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.sub">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>sub
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.tan">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>tan
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.tanh">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>tanh
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.trunc">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>trunc
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>EUCLID</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>ROUND_CEIL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>ROUND_DOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>ROUND_FLOOR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>ROUND_HALF_CEIL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>ROUND_HALF_DOWN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>ROUND_HALF_EVEN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>ROUND_HALF_FLOOR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>ROUND_HALF_UP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>ROUND_UP</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>maxE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>minE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>modulo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>precision</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>rounding</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>toExpNeg</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">decimal.js.Decimal.</span>toExpPos</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.decimal.js.Decimal.prototype">module decimal.js.Decimal.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.abs">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>abs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.absoluteValue">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>absoluteValue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.acos">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>acos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.acosh">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>acosh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.add">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>add
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.asin">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>asin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.asinh">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>asinh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.atan">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>atan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.atanh">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>atanh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.cbrt">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>cbrt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.ceil">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>ceil
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.cmp">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>cmp
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.comparedTo">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>comparedTo
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.cos">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>cos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.cosh">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>cosh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.cosine">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>cosine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.cubeRoot">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>cubeRoot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.decimalPlaces">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>decimalPlaces
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.div">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>div
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.divToInt">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>divToInt
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.dividedBy">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>dividedBy
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.dividedToIntegerBy">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>dividedToIntegerBy
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.dp">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>dp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.eq">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>eq
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.equals">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>equals
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.exp">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>exp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.floor">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>floor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.greaterThan">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>greaterThan
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.greaterThanOrEqualTo">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>greaterThanOrEqualTo
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.gt">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>gt
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.gte">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>gte
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.hyperbolicCosine">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>hyperbolicCosine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.hyperbolicSine">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>hyperbolicSine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.hyperbolicTangent">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>hyperbolicTangent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.inverseCosine">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>inverseCosine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.inverseHyperbolicCosine">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>inverseHyperbolicCosine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.inverseHyperbolicSine">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>inverseHyperbolicSine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.inverseHyperbolicTangent">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>inverseHyperbolicTangent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.inverseSine">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>inverseSine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.inverseTangent">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>inverseTangent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.isFinite">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isFinite
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.isInt">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isInt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.isInteger">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isInteger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.isNaN">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isNaN
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.isNeg">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isNeg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.isNegative">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isNegative
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.isPos">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isPos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.isPositive">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isPositive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.isZero">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isZero
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.lessThan">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>lessThan
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.lessThanOrEqualTo">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>lessThanOrEqualTo
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.ln">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>ln
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.log">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>log
            <span class="apidocSignatureSpan">(base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.logarithm">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>logarithm
            <span class="apidocSignatureSpan">(base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.lt">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>lt
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.lte">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>lte
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.minus">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>minus
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.mod">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>mod
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.modulo">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>modulo
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.mul">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>mul
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.naturalExponential">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>naturalExponential
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.naturalLogarithm">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>naturalLogarithm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.neg">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>neg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.negated">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>negated
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.plus">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>plus
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.pow">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>pow
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.precision">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>precision
            <span class="apidocSignatureSpan">(z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.round">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>round
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.sd">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>sd
            <span class="apidocSignatureSpan">(z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.sin">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>sin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.sine">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>sine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.sinh">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>sinh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.sqrt">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>sqrt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.squareRoot">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>squareRoot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.sub">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>sub
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.tan">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>tan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.tangent">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>tangent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.tanh">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>tanh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.times">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>times
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toBinary">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toBinary
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toDP">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toDP
            <span class="apidocSignatureSpan">(dp, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toDecimalPlaces">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toDecimalPlaces
            <span class="apidocSignatureSpan">(dp, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toExponential">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toExponential
            <span class="apidocSignatureSpan">(dp, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toFixed">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toFixed
            <span class="apidocSignatureSpan">(dp, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toFraction">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toFraction
            <span class="apidocSignatureSpan">(maxD)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toHex">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toHex
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toHexadecimal">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toHexadecimal
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toJSON">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toNearest">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toNearest
            <span class="apidocSignatureSpan">(y, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toNumber">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toNumber
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toOctal">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toOctal
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toPower">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toPower
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toPrecision">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toPrecision
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toSD">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toSD
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toSignificantDigits">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toSignificantDigits
            <span class="apidocSignatureSpan">(sd, rm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.toString">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.trunc">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>trunc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.truncated">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>truncated
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.decimal.js.Decimal.prototype.valueOf">
            function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>valueOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.decimal.js" id="apidoc.module.decimal.js">module decimal.js</a></h1>




    <h2>
        <a href="#apidoc.element.decimal.js.js" id="apidoc.element.decimal.js.js">
        function <span class="apidocSignatureSpan">decimal.</span>js
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decimal(v) {
  var e, i, t,
    x = this;

  // Decimal called without new.
  if (!(x instanceof Decimal)) return new Decimal(v);

  // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
  // which points to Object.
  x.constructor = Decimal;

  // Duplicate.
  if (v instanceof Decimal) {
    x.s = v.s;
    x.e = v.e;
    x.d = (v = v.d) ? v.slice() : v;
    return;
  }

  t = typeof v;

  if (t === 'number') {
    if (v === 0) {
      x.s = 1 / v &lt; 0 ? -1 : 1;
      x.e = 0;
      x.d = [0];
      return;
    }

    if (v &lt; 0) {
      v = -v;
      x.s = -1;
    } else {
      x.s = 1;
    }

    // Fast path for small integers.
    if (v === ~~v &amp;&amp; v &lt; 1e7) {
      for (e = 0, i = v; i &gt;= 10; i /= 10) e++;
      x.e = e;
      x.d = [v];
      return;

    // Infinity, NaN.
    } else if (v * 0 !== 0) {
      if (!v) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return;
    }

    return parseDecimal(x, v.toString());

  } else if (t !== 'string') {
    throw Error(invalidArgument + v);
  }

  // Minus sign?
  if (v.charCodeAt(0) === 45) {
    v = v.slice(1);
    x.s = -1;
  } else {
    x.s = 1;
  }

  return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal" id="apidoc.element.decimal.js.Decimal">
        function <span class="apidocSignatureSpan">decimal.js.</span>Decimal
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decimal(v) {
  var e, i, t,
    x = this;

  // Decimal called without new.
  if (!(x instanceof Decimal)) return new Decimal(v);

  // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
  // which points to Object.
  x.constructor = Decimal;

  // Duplicate.
  if (v instanceof Decimal) {
    x.s = v.s;
    x.e = v.e;
    x.d = (v = v.d) ? v.slice() : v;
    return;
  }

  t = typeof v;

  if (t === 'number') {
    if (v === 0) {
      x.s = 1 / v &lt; 0 ? -1 : 1;
      x.e = 0;
      x.d = [0];
      return;
    }

    if (v &lt; 0) {
      v = -v;
      x.s = -1;
    } else {
      x.s = 1;
    }

    // Fast path for small integers.
    if (v === ~~v &amp;&amp; v &lt; 1e7) {
      for (e = 0, i = v; i &gt;= 10; i /= 10) e++;
      x.e = e;
      x.d = [v];
      return;

    // Infinity, NaN.
    } else if (v * 0 !== 0) {
      if (!v) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return;
    }

    return parseDecimal(x, v.toString());

  } else if (t !== 'string') {
    throw Error(invalidArgument + v);
  }

  // Minus sign?
  if (v.charCodeAt(0) === 45) {
    v = v.slice(1);
    x.s = -1;
  } else {
    x.s = 1;
  }

  return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.abs" id="apidoc.element.decimal.js.abs">
        function <span class="apidocSignatureSpan">decimal.js.</span>abs
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function abs(x) {
  return new this(x).abs();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    external = false;

    // Initial estimate.
    s = x.s * Math.pow(x.s * x, 1 / 3);

     // Math.cbrt underflow/overflow?
     // Pass x to Math.pow as integer, then adjust the exponent of the result.
    if (!s || Math.<span class="apidocCodeKeywordSpan">abs</span>(s) == 1 / 0) {
n = digitsToString(x.d);
e = x.e;

// Adjust n exponent so it is a multiple of 3 away from x exponent.
if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
s = Math.pow(n, 1 / 3);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.acos" id="apidoc.element.decimal.js.acos">
        function <span class="apidocSignatureSpan">decimal.js.</span>acos
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acos(x) {
  return new this(x).acos();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
 * Return a new Decimal whose value is the arccosine in radians of `x`.
 *
 * x {number|string|Decimal}
 *
 */
function acos(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">acos</span>();
}


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.acosh" id="apidoc.element.decimal.js.acosh">
        function <span class="apidocSignatureSpan">decimal.js.</span>acosh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acosh(x) {
  return new this(x).acosh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function acosh(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">acosh</span>();
}


/*
 * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.add" id="apidoc.element.decimal.js.add">
        function <span class="apidocSignatureSpan">decimal.js.</span>add
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(x, y) {
  return new this(x).plus(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.asin" id="apidoc.element.decimal.js.asin">
        function <span class="apidocSignatureSpan">decimal.js.</span>asin
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asin(x) {
  return new this(x).asin();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

  // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.<span class="apidocCodeKeywordSpan">asin</span>();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return halfPi.minus(x);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.asinh" id="apidoc.element.decimal.js.asinh">
        function <span class="apidocSignatureSpan">decimal.js.</span>asinh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asinh(x) {
  return new this(x).asinh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function asinh(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">asinh</span>();
}


/*
 * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.atan" id="apidoc.element.decimal.js.atan">
        function <span class="apidocSignatureSpan">decimal.js.</span>atan
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atan(x) {
  return new this(x).atan();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).<span class="apidocCodeKeywordSpan">atan</span>();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(2);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.atan2" id="apidoc.element.decimal.js.atan2">
        function <span class="apidocSignatureSpan">decimal.js.</span>atan2
        <span class="apidocSignatureSpan">(y, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r,
    pr = this.precision,
    rm = this.rounding,
    wpr = pr + 4;

  // Either NaN
  if (!y.s || !x.s) {
    r = new this(NaN);

  // Both Infinity
  } else if (!y.d &amp;&amp; !x.d) {
    r = getPi(this, wpr, 1).times(x.s &gt; 0 ? 0.25 : 0.75);
    r.s = y.s;

  // x is Infinity or y is 0
  } else if (!x.d || y.isZero()) {
    r = x.s &lt; 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;

  // y is Infinity or x is 0
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;

  // Both non-zero and finite
  } else if (x.s &lt; 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s &lt; 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }

  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.atanh" id="apidoc.element.decimal.js.atanh">
        function <span class="apidocSignatureSpan">decimal.js.</span>atanh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atanh(x) {
  return new this(x).atanh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function atanh(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">atanh</span>();
}


/*
 * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
 * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.cbrt" id="apidoc.element.decimal.js.cbrt">
        function <span class="apidocSignatureSpan">decimal.js.</span>cbrt
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cbrt(x) {
  return new this(x).cbrt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  cbrt(-0) = -0
 *  cbrt(1)  =  1
 *  cbrt(-1) = -1
 *  cbrt(N)  =  N
 *  cbrt(-I) = -I
 *  cbrt(I)  =  I
 *
 * Math.<span class="apidocCodeKeywordSpan">cbrt</span>(x) = (x &lt; 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
 *
 */
P.cubeRoot = P.cbrt = function () {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx,
    x = this,
    Ctor = x.constructor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.ceil" id="apidoc.element.decimal.js.ceil">
        function <span class="apidocSignatureSpan">decimal.js.</span>ceil
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x                             // '0.3'
```

The methods that return a Decimal can be chained.

```js
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').<span class="apidocCodeKeywordSpan
">ceil</span>()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.clone" id="apidoc.element.decimal.js.clone">
        function <span class="apidocSignatureSpan">decimal.js.</span>clone
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clone(obj) {
  var i, p, ps;

  /*
   * The Decimal constructor and exported function.
   * Return a new Decimal instance.
   *
   * v {number|string|Decimal} A numeric value.
   *
   */
  function Decimal(v) {
    var e, i, t,
      x = this;

    // Decimal called without new.
    if (!(x instanceof Decimal)) return new Decimal(v);

    // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
    // which points to Object.
    x.constructor = Decimal;

    // Duplicate.
    if (v instanceof Decimal) {
      x.s = v.s;
      x.e = v.e;
      x.d = (v = v.d) ? v.slice() : v;
      return;
    }

    t = typeof v;

    if (t === 'number') {
      if (v === 0) {
        x.s = 1 / v &lt; 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }

      if (v &lt; 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }

      // Fast path for small integers.
      if (v === ~~v &amp;&amp; v &lt; 1e7) {
        for (e = 0, i = v; i &gt;= 10; i /= 10) e++;
        x.e = e;
        x.d = [v];
        return;

      // Infinity, NaN.
      } else if (v * 0 !== 0) {
        if (!v) x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }

      return parseDecimal(x, v.toString());

    } else if (t !== 'string') {
      throw Error(invalidArgument + v);
    }

    // Minus sign?
    if (v.charCodeAt(0) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      x.s = 1;
    }

    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }

  Decimal.prototype = P;

  Decimal.ROUND_UP = 0;
  Decimal.ROUND_DOWN = 1;
  Decimal.ROUND_CEIL = 2;
  Decimal.ROUND_FLOOR = 3;
  Decimal.ROUND_HALF_UP = 4;
  Decimal.ROUND_HALF_DOWN = 5;
  Decimal.ROUND_HALF_EVEN = 6;
  Decimal.ROUND_HALF_CEIL = 7;
  Decimal.ROUND_HALF_FLOOR = 8;
  Decimal.EUCLID = 9;

  Decimal.config = Decimal.set = config;
  Decimal.clone = clone;

  Decimal.abs = abs;
  Decimal.acos = acos;
  Decimal.acosh = acosh;        // ES6
  Decimal.add = add;
  Decimal.asin = asin;
  Decimal.asinh = asinh;        // ES6
  Decimal.atan = atan;
  Decimal.atanh = atanh;        // ES6
  Decimal.atan2 = atan2;
  Decimal.cbrt = cbrt;          // ES6
  Decimal.ceil = ceil;
  Decimal.cos = cos;
  Decimal.cosh = cosh;          // ES6
  Decimal.div = div;
  Decimal.exp = exp;
  Decimal.floor = floor;
  Decimal.hypot = hypot;        // ES6
  Decimal.ln = ln;
  Decimal.log = log;
  Decimal.log10 = log10;        // ES6
  Decimal.log2 = log2;          // ES6
  Decimal.max = max;
  Decimal.min = min;
  Decimal.mod = mod;
  Decimal.mul = mul;
  Decimal.pow = pow;
  Decimal.random = random;
  Decimal.round = round;
  Decimal.sign = sign;          // ES6
  Decimal.sin = sin;
  Decimal.sinh = sinh;          // ES6
  Decimal.sqrt = sqrt;
  Decimal.sub = sub;
  Decimal.tan = tan;
  Decimal.tanh = tanh;          // ES6
  Decimal.trunc = trunc;        // ES6

  if (obj === void 0) obj = {};
  if (obj) {
    ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
    for (i = 0; i &lt; ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
  }

  Decimal.config(obj);

  return Decimal;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
applies to all Decimal numbers created from it.

```js
// Set the precision and rounding of the default Decimal constructor
Decimal.set({ precision: 5, rounding: 4 })

// Create another Decimal constructor, optionally passing in a configuration object
Decimal10 = Decimal.<span class="apidocCodeKeywordSpan">clone</span>({ precision: 10, rounding: 1 })

x = new Decimal(5)
y = new Decimal10(5)

x.div(3)                           // '1.6667'
y.div(3)                           // '1.666666666'
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.config" id="apidoc.element.decimal.js.config">
        function <span class="apidocSignatureSpan">decimal.js.</span>config
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(obj) {
  if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
  var i, p, v,
    ps = [
      'precision', 1, MAX_DIGITS,
      'rounding', 0, 8,
      'toExpNeg', -EXP_LIMIT, 0,
      'toExpPos', 0, EXP_LIMIT,
      'maxE', 0, EXP_LIMIT,
      'minE', -EXP_LIMIT, 0,
      'modulo', 0, 9
    ];

  for (i = 0; i &lt; ps.length; i += 3) {
    if ((v = obj[p = ps[i]]) !== void 0) {
      if (mathfloor(v) === v &amp;&amp; v &gt;= ps[i + 1] &amp;&amp; v &lt;= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ': ' + v);
    }
  }

  if ((v = obj[p = 'crypto']) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != 'undefined' &amp;&amp; crypto &amp;&amp;
          (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ': ' + v);
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // The initial configuration properties of the Decimal constructor.
    Decimal = {

// These values must be integers within the stated ranges (inclusive).
// Most of these values can be changed at run-time using the `Decimal.config` method.

// The maximum number of significant digits of the result of a calculation or base conversion.
// E.g. `Decimal.<span class="apidocCodeKeywordSpan">config</span>({ precision: 20 });`
precision: 20,                         // 1 to MAX_DIGITS

// The rounding mode used when rounding to `precision`.
//
// ROUND_UP         0 Away from zero.
// ROUND_DOWN       1 Towards zero.
// ROUND_CEIL       2 Towards +Infinity.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.cos" id="apidoc.element.decimal.js.cos">
        function <span class="apidocSignatureSpan">decimal.js.</span>cos
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cos(x) {
  return new this(x).cos();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function cos(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">cos</span>();
}


/*
 * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
 * significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.cosh" id="apidoc.element.decimal.js.cosh">
        function <span class="apidocSignatureSpan">decimal.js.</span>cosh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cosh(x) {
  return new this(x).cosh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;

  return divide(x.sinh(), x.<span class="apidocCodeKeywordSpan">cosh</span>(), Ctor.precision = pr, Ctor.rounding = rm);
};


/*
 * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
 * this Decimal.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.default" id="apidoc.element.decimal.js.default">
        function <span class="apidocSignatureSpan">decimal.js.</span>default
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decimal(v) {
  var e, i, t,
    x = this;

  // Decimal called without new.
  if (!(x instanceof Decimal)) return new Decimal(v);

  // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
  // which points to Object.
  x.constructor = Decimal;

  // Duplicate.
  if (v instanceof Decimal) {
    x.s = v.s;
    x.e = v.e;
    x.d = (v = v.d) ? v.slice() : v;
    return;
  }

  t = typeof v;

  if (t === 'number') {
    if (v === 0) {
      x.s = 1 / v &lt; 0 ? -1 : 1;
      x.e = 0;
      x.d = [0];
      return;
    }

    if (v &lt; 0) {
      v = -v;
      x.s = -1;
    } else {
      x.s = 1;
    }

    // Fast path for small integers.
    if (v === ~~v &amp;&amp; v &lt; 1e7) {
      for (e = 0, i = v; i &gt;= 10; i /= 10) e++;
      x.e = e;
      x.d = [v];
      return;

    // Infinity, NaN.
    } else if (v * 0 !== 0) {
      if (!v) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return;
    }

    return parseDecimal(x, v.toString());

  } else if (t !== 'string') {
    throw Error(invalidArgument + v);
  }

  // Minus sign?
  if (v.charCodeAt(0) === 45) {
    v = v.slice(1);
    x.s = -1;
  } else {
    x.s = 1;
  }

  return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.div" id="apidoc.element.decimal.js.div">
        function <span class="apidocSignatureSpan">decimal.js.</span>div
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function div(x, y) {
  return new this(x).div(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().<span class="apidocCodeKeywordSpan">div</span>(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.exp" id="apidoc.element.decimal.js.exp">
        function <span class="apidocSignatureSpan">decimal.js.</span>exp
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exp(x) {
  return new this(x).exp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Previously, the argument was initially reduced by
* exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
* to first put r in the range [0, ln10], before dividing by 32 until |x| &lt; 0.1, but this was
* found to be slower than just dividing repeatedly by 32 as above.
*
* Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
* Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
* (Math object integer min/max: Math.<span class="apidocCodeKeywordSpan">exp</span>(709) = 8.2e+307, Math.exp(-745) = 5e-324)
*
*  exp(Infinity)  = Infinity
*  exp(-Infinity) = 0
*  exp(NaN)       = NaN
*  exp(0)        = 1
*
*  exp(x) is non-terminating for any finite, non-zero x.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.floor" id="apidoc.element.decimal.js.floor">
        function <span class="apidocSignatureSpan">decimal.js.</span>floor
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.minus(0.1)                  // '0.2'
x                             // '0.3'
```

The methods that return a Decimal can be chained.

```js
x.dividedBy(y).plus(z).times(9).<span class="apidocCodeKeywordSpan">floor</span>()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.hypot" id="apidoc.element.decimal.js.hypot">
        function <span class="apidocSignatureSpan">decimal.js.</span>hypot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hypot() {
  var i, n,
    t = new this(0);

  external = false;

  for (i = 0; i &lt; arguments.length;) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }

  external = true;

  return t.sqrt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.js.Decimal" id="apidoc.element.decimal.js.js.Decimal">
        function <span class="apidocSignatureSpan">decimal.js.</span>js.Decimal
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decimal(v) {
  var e, i, t,
    x = this;

  // Decimal called without new.
  if (!(x instanceof Decimal)) return new Decimal(v);

  // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
  // which points to Object.
  x.constructor = Decimal;

  // Duplicate.
  if (v instanceof Decimal) {
    x.s = v.s;
    x.e = v.e;
    x.d = (v = v.d) ? v.slice() : v;
    return;
  }

  t = typeof v;

  if (t === 'number') {
    if (v === 0) {
      x.s = 1 / v &lt; 0 ? -1 : 1;
      x.e = 0;
      x.d = [0];
      return;
    }

    if (v &lt; 0) {
      v = -v;
      x.s = -1;
    } else {
      x.s = 1;
    }

    // Fast path for small integers.
    if (v === ~~v &amp;&amp; v &lt; 1e7) {
      for (e = 0, i = v; i &gt;= 10; i /= 10) e++;
      x.e = e;
      x.d = [v];
      return;

    // Infinity, NaN.
    } else if (v * 0 !== 0) {
      if (!v) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return;
    }

    return parseDecimal(x, v.toString());

  } else if (t !== 'string') {
    throw Error(invalidArgument + v);
  }

  // Minus sign?
  if (v.charCodeAt(0) === 45) {
    v = v.slice(1);
    x.s = -1;
  } else {
    x.s = 1;
  }

  return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.ln" id="apidoc.element.decimal.js.ln">
        function <span class="apidocSignatureSpan">decimal.js.</span>ln
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ln(x) {
  return new this(x).ln();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  x = x.times(x).minus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.<span class="apidocCodeKeywordSpan">ln</span>();
};


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
 * of this Decimal.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.log" id="apidoc.element.decimal.js.log">
        function <span class="apidocSignatureSpan">decimal.js.</span>log
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log(x, y) {
  return new this(x).log(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Estimate result exponent.
// x^y = 10^e,  where e = y * log10(x)
// log10(x) = log10(x_significand) + x_exponent
// log10(x_significand) = ln(x_significand) / ln(10)
k = mathpow(+x, yn);
e = k == 0 || !isFinite(k)
  ? mathfloor(yn * (Math.<span class="apidocCodeKeywordSpan">log</span>('0.' + digitsToString(x.d)) / Math.LN10 + x.e +
1))
  : new Ctor(k + '').e;

// Estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

// Overflow/underflow?
if (e &gt; Ctor.maxE + 1 || e &lt; Ctor.minE - 1) return new Ctor(e &gt; 0 ? sign / 0 : 0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.log10" id="apidoc.element.decimal.js.log10">
        function <span class="apidocSignatureSpan">decimal.js.</span>log10
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log10(x) {
  return new this(x).log(10);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.log2" id="apidoc.element.decimal.js.log2">
        function <span class="apidocSignatureSpan">decimal.js.</span>log2
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log2(x) {
  return new this(x).log(2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.max" id="apidoc.element.decimal.js.max">
        function <span class="apidocSignatureSpan">decimal.js.</span>max
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function max() {
  return maxOrMin(this, arguments, 'lt');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!x.d) return new Ctor(NaN);

// cos(0) = cos(-0) = 1
if (!x.d[0]) return new Ctor(1);

pr = Ctor.precision;
rm = Ctor.rounding;
Ctor.precision = pr + Math.<span class="apidocCodeKeywordSpan">max</span>(x.e, x.sd()) + LOG_BASE;
Ctor.rounding = 1;

x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

Ctor.precision = pr;
Ctor.rounding = rm;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.min" id="apidoc.element.decimal.js.min">
        function <span class="apidocSignatureSpan">decimal.js.</span>min
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min() {
  return maxOrMin(this, arguments, 'gt');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// TODO? if (x &gt;= 1 &amp;&amp; pr &lt;= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

// Argument reduction
// Ensure |x| &lt; 0.42
// atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

k = Math.<span class="apidocCodeKeywordSpan">min</span>(28, wpr / LOG_BASE + 2 | 0);

for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

external = false;

j = Math.ceil(wpr / LOG_BASE);
n = 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.mod" id="apidoc.element.decimal.js.mod">
        function <span class="apidocSignatureSpan">decimal.js.</span>mod
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mod(x, y) {
  return new this(x).mod(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.<span class="apidocCodeKeywordSpan">mod</span>(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        //
true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
x.toExponential(5)              // '2.55500e+2'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.mul" id="apidoc.element.decimal.js.mul">
        function <span class="apidocSignatureSpan">decimal.js.</span>mul
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mul(x, y) {
  return new this(x).mul(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function mul(x, y) {
  return new this(x).<span class="apidocCodeKeywordSpan">mul</span>(y);
}


/*
 * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
 * significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.pow" id="apidoc.element.decimal.js.pow">
        function <span class="apidocSignatureSpan">decimal.js.</span>pow
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pow(x, y) {
  return new this(x).pow(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).<span class="apidocCodeKeywordSpan">pow</span>(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.random" id="apidoc.element.decimal.js.random">
        function <span class="apidocSignatureSpan">decimal.js.</span>random
        <span class="apidocSignatureSpan">(sd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function random(sd) {
  var d, e, k, n,
    i = 0,
    r = new this(1),
    rd = [];

  if (sd === void 0) sd = this.precision;
  else checkInt32(sd, 1, MAX_DIGITS);

  k = Math.ceil(sd / LOG_BASE);

  if (!this.crypto) {
    for (; i &lt; k;) rd[i++] = Math.random() * 1e7 | 0;

  // Browsers supporting crypto.getRandomValues.
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));

    for (; i &lt; k;) {
      n = d[i];

      // 0 &lt;= n &lt; 4294967296
      // Probability n &gt;= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
      if (n &gt;= 4.29e9) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {

        // 0 &lt;= n &lt;= 4289999999
        // 0 &lt;= (n % 1e7) &lt;= 9999999
        rd[i++] = n % 1e7;
      }
    }

  // Node.js supporting crypto.randomBytes.
  } else if (crypto.randomBytes) {

    // buffer
    d = crypto.randomBytes(k *= 4);

    for (; i &lt; k;) {

      // 0 &lt;= n &lt; 2147483648
      n = d[i] + (d[i + 1] &lt;&lt; 8) + (d[i + 2] &lt;&lt; 16) + ((d[i + 3] &amp; 0x7f) &lt;&lt; 24);

      // Probability n &gt;= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
      if (n &gt;= 2.14e9) {
        crypto.randomBytes(4).copy(d, i);
      } else {

        // 0 &lt;= n &lt;= 2139999999
        // 0 &lt;= (n % 1e7) &lt;= 9999999
        rd.push(n % 1e7);
        i += 4;
      }
    }

    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }

  k = rd[--i];
  sd %= LOG_BASE;

  // Convert trailing digits to zeros according to sd.
  if (k &amp;&amp; sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }

  // Remove trailing words which are zero.
  for (; rd[i] === 0; i--) rd.pop();

  // Zero?
  if (i &lt; 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;

    // Remove leading words which are zero and adjust exponent accordingly.
    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

    // Count the digits of the first word of rd to determine leading zeros.
    for (k = 1, n = rd[0]; n &gt;= 10; n /= 10) k++;

    // Adjust the exponent for leading zeros of the first word of rd.
    if (k &lt; LOG_BASE) e -= LOG_BASE - k;
  }

  r.e = e;
  r.d = rd;

  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (sd === void 0) sd = this.precision;
    else checkInt32(sd, 1, MAX_DIGITS);

    k = Math.ceil(sd / LOG_BASE);

    if (!this.crypto) {
for (; i &lt; k;) rd[i++] = Math.<span class="apidocCodeKeywordSpan">random</span>() * 1e7 | 0;

    // Browsers supporting crypto.getRandomValues.
    } else if (crypto.getRandomValues) {
d = crypto.getRandomValues(new Uint32Array(k));

for (; i &lt; k;) {
  n = d[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.round" id="apidoc.element.decimal.js.round">
        function <span class="apidocSignatureSpan">decimal.js.</span>round
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.set" id="apidoc.element.decimal.js.set">
        function <span class="apidocSignatureSpan">decimal.js.</span>set
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(obj) {
  if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
  var i, p, v,
    ps = [
      'precision', 1, MAX_DIGITS,
      'rounding', 0, 8,
      'toExpNeg', -EXP_LIMIT, 0,
      'toExpPos', 0, EXP_LIMIT,
      'maxE', 0, EXP_LIMIT,
      'minE', -EXP_LIMIT, 0,
      'modulo', 0, 9
    ];

  for (i = 0; i &lt; ps.length; i += 3) {
    if ((v = obj[p = ps[i]]) !== void 0) {
      if (mathfloor(v) === v &amp;&amp; v &gt;= ps[i + 1] &amp;&amp; v &lt;= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ': ' + v);
    }
  }

  if ((v = obj[p = 'crypto']) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != 'undefined' &amp;&amp; crypto &amp;&amp;
          (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ': ' + v);
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
specified by the `precision` and `rounding` properties of the Decimal constructor.

Multiple Decimal constructors can be created, each with their own independent configuration which
applies to all Decimal numbers created from it.

```js
// Set the precision and rounding of the default Decimal constructor
Decimal.<span class="apidocCodeKeywordSpan">set</span>({ precision: 5, rounding: 4 })

// Create another Decimal constructor, optionally passing in a configuration object
Decimal10 = Decimal.clone({ precision: 10, rounding: 1 })

x = new Decimal(5)
y = new Decimal10(5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.sign" id="apidoc.element.decimal.js.sign">
        function <span class="apidocSignatureSpan">decimal.js.</span>sign
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(x) {
  x = new this(x);
  return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.sin" id="apidoc.element.decimal.js.sin">
        function <span class="apidocSignatureSpan">decimal.js.</span>sin
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sin(x) {
  return new this(x).sin();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (x.isZero()) return new Ctor(x);

pr = Ctor.precision;
rm = Ctor.rounding;
Ctor.precision = pr + 10;
Ctor.rounding = 1;

x = x.<span class="apidocCodeKeywordSpan">sin</span>();
x.s = 1;
x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

Ctor.precision = pr;
Ctor.rounding = rm;

return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.sinh" id="apidoc.element.decimal.js.sinh">
        function <span class="apidocSignatureSpan">decimal.js.</span>sinh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sinh(x) {
  return new this(x).sinh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;

  return divide(x.<span class="apidocCodeKeywordSpan">sinh</span>(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};


/*
 * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
 * this Decimal.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.sqrt" id="apidoc.element.decimal.js.sqrt">
        function <span class="apidocSignatureSpan">decimal.js.</span>sqrt
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sqrt(x) {
  return new this(x).sqrt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.<span class="apidocCodeKeywordSpan">sqrt</span>().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.sub" id="apidoc.element.decimal.js.sub">
        function <span class="apidocSignatureSpan">decimal.js.</span>sub
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sub(x, y) {
  return new this(x).sub(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function sub(x, y) {
  return new this(x).<span class="apidocCodeKeywordSpan">sub</span>(y);
}


/*
 * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.tan" id="apidoc.element.decimal.js.tan">
        function <span class="apidocSignatureSpan">decimal.js.</span>tan
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tan(x) {
  return new this(x).tan();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function tan(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">tan</span>();
}


/*
 * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.tanh" id="apidoc.element.decimal.js.tanh">
        function <span class="apidocSignatureSpan">decimal.js.</span>tanh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tanh(x) {
  return new this(x).tanh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function tanh(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">tanh</span>();
}


/*
 * Return a new Decimal whose value is `x` truncated to an integer.
 *
 * x {number|string|Decimal}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.trunc" id="apidoc.element.decimal.js.trunc">
        function <span class="apidocSignatureSpan">decimal.js.</span>trunc
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.decimal.js.Decimal" id="apidoc.module.decimal.js.Decimal">module decimal.js.Decimal</a></h1>




    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.Decimal" id="apidoc.element.decimal.js.Decimal.Decimal">
        function <span class="apidocSignatureSpan">decimal.js.</span>Decimal
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decimal(v) {
  var e, i, t,
    x = this;

  // Decimal called without new.
  if (!(x instanceof Decimal)) return new Decimal(v);

  // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
  // which points to Object.
  x.constructor = Decimal;

  // Duplicate.
  if (v instanceof Decimal) {
    x.s = v.s;
    x.e = v.e;
    x.d = (v = v.d) ? v.slice() : v;
    return;
  }

  t = typeof v;

  if (t === 'number') {
    if (v === 0) {
      x.s = 1 / v &lt; 0 ? -1 : 1;
      x.e = 0;
      x.d = [0];
      return;
    }

    if (v &lt; 0) {
      v = -v;
      x.s = -1;
    } else {
      x.s = 1;
    }

    // Fast path for small integers.
    if (v === ~~v &amp;&amp; v &lt; 1e7) {
      for (e = 0, i = v; i &gt;= 10; i /= 10) e++;
      x.e = e;
      x.d = [v];
      return;

    // Infinity, NaN.
    } else if (v * 0 !== 0) {
      if (!v) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return;
    }

    return parseDecimal(x, v.toString());

  } else if (t !== 'string') {
    throw Error(invalidArgument + v);
  }

  // Minus sign?
  if (v.charCodeAt(0) === 45) {
    v = v.slice(1);
    x.s = -1;
  } else {
    x.s = 1;
  }

  return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.abs" id="apidoc.element.decimal.js.Decimal.abs">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>abs
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function abs(x) {
  return new this(x).abs();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    external = false;

    // Initial estimate.
    s = x.s * Math.pow(x.s * x, 1 / 3);

     // Math.cbrt underflow/overflow?
     // Pass x to Math.pow as integer, then adjust the exponent of the result.
    if (!s || Math.<span class="apidocCodeKeywordSpan">abs</span>(s) == 1 / 0) {
n = digitsToString(x.d);
e = x.e;

// Adjust n exponent so it is a multiple of 3 away from x exponent.
if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
s = Math.pow(n, 1 / 3);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.acos" id="apidoc.element.decimal.js.Decimal.acos">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>acos
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acos(x) {
  return new this(x).acos();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
 * Return a new Decimal whose value is the arccosine in radians of `x`.
 *
 * x {number|string|Decimal}
 *
 */
function acos(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">acos</span>();
}


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.acosh" id="apidoc.element.decimal.js.Decimal.acosh">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>acosh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acosh(x) {
  return new this(x).acosh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function acosh(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">acosh</span>();
}


/*
 * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.add" id="apidoc.element.decimal.js.Decimal.add">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>add
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(x, y) {
  return new this(x).plus(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.asin" id="apidoc.element.decimal.js.Decimal.asin">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>asin
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asin(x) {
  return new this(x).asin();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

  // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.<span class="apidocCodeKeywordSpan">asin</span>();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return halfPi.minus(x);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.asinh" id="apidoc.element.decimal.js.Decimal.asinh">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>asinh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asinh(x) {
  return new this(x).asinh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function asinh(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">asinh</span>();
}


/*
 * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.atan" id="apidoc.element.decimal.js.Decimal.atan">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>atan
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atan(x) {
  return new this(x).atan();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).<span class="apidocCodeKeywordSpan">atan</span>();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(2);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.atan2" id="apidoc.element.decimal.js.Decimal.atan2">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>atan2
        <span class="apidocSignatureSpan">(y, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r,
    pr = this.precision,
    rm = this.rounding,
    wpr = pr + 4;

  // Either NaN
  if (!y.s || !x.s) {
    r = new this(NaN);

  // Both Infinity
  } else if (!y.d &amp;&amp; !x.d) {
    r = getPi(this, wpr, 1).times(x.s &gt; 0 ? 0.25 : 0.75);
    r.s = y.s;

  // x is Infinity or y is 0
  } else if (!x.d || y.isZero()) {
    r = x.s &lt; 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;

  // y is Infinity or x is 0
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;

  // Both non-zero and finite
  } else if (x.s &lt; 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s &lt; 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }

  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.atanh" id="apidoc.element.decimal.js.Decimal.atanh">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>atanh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atanh(x) {
  return new this(x).atanh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function atanh(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">atanh</span>();
}


/*
 * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
 * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.cbrt" id="apidoc.element.decimal.js.Decimal.cbrt">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>cbrt
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cbrt(x) {
  return new this(x).cbrt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  cbrt(-0) = -0
 *  cbrt(1)  =  1
 *  cbrt(-1) = -1
 *  cbrt(N)  =  N
 *  cbrt(-I) = -I
 *  cbrt(I)  =  I
 *
 * Math.<span class="apidocCodeKeywordSpan">cbrt</span>(x) = (x &lt; 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
 *
 */
P.cubeRoot = P.cbrt = function () {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx,
    x = this,
    Ctor = x.constructor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.ceil" id="apidoc.element.decimal.js.Decimal.ceil">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>ceil
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x                             // '0.3'
```

The methods that return a Decimal can be chained.

```js
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').<span class="apidocCodeKeywordSpan
">ceil</span>()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.clone" id="apidoc.element.decimal.js.Decimal.clone">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>clone
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clone(obj) {
  var i, p, ps;

  /*
   * The Decimal constructor and exported function.
   * Return a new Decimal instance.
   *
   * v {number|string|Decimal} A numeric value.
   *
   */
  function Decimal(v) {
    var e, i, t,
      x = this;

    // Decimal called without new.
    if (!(x instanceof Decimal)) return new Decimal(v);

    // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
    // which points to Object.
    x.constructor = Decimal;

    // Duplicate.
    if (v instanceof Decimal) {
      x.s = v.s;
      x.e = v.e;
      x.d = (v = v.d) ? v.slice() : v;
      return;
    }

    t = typeof v;

    if (t === 'number') {
      if (v === 0) {
        x.s = 1 / v &lt; 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }

      if (v &lt; 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }

      // Fast path for small integers.
      if (v === ~~v &amp;&amp; v &lt; 1e7) {
        for (e = 0, i = v; i &gt;= 10; i /= 10) e++;
        x.e = e;
        x.d = [v];
        return;

      // Infinity, NaN.
      } else if (v * 0 !== 0) {
        if (!v) x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }

      return parseDecimal(x, v.toString());

    } else if (t !== 'string') {
      throw Error(invalidArgument + v);
    }

    // Minus sign?
    if (v.charCodeAt(0) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      x.s = 1;
    }

    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }

  Decimal.prototype = P;

  Decimal.ROUND_UP = 0;
  Decimal.ROUND_DOWN = 1;
  Decimal.ROUND_CEIL = 2;
  Decimal.ROUND_FLOOR = 3;
  Decimal.ROUND_HALF_UP = 4;
  Decimal.ROUND_HALF_DOWN = 5;
  Decimal.ROUND_HALF_EVEN = 6;
  Decimal.ROUND_HALF_CEIL = 7;
  Decimal.ROUND_HALF_FLOOR = 8;
  Decimal.EUCLID = 9;

  Decimal.config = Decimal.set = config;
  Decimal.clone = clone;

  Decimal.abs = abs;
  Decimal.acos = acos;
  Decimal.acosh = acosh;        // ES6
  Decimal.add = add;
  Decimal.asin = asin;
  Decimal.asinh = asinh;        // ES6
  Decimal.atan = atan;
  Decimal.atanh = atanh;        // ES6
  Decimal.atan2 = atan2;
  Decimal.cbrt = cbrt;          // ES6
  Decimal.ceil = ceil;
  Decimal.cos = cos;
  Decimal.cosh = cosh;          // ES6
  Decimal.div = div;
  Decimal.exp = exp;
  Decimal.floor = floor;
  Decimal.hypot = hypot;        // ES6
  Decimal.ln = ln;
  Decimal.log = log;
  Decimal.log10 = log10;        // ES6
  Decimal.log2 = log2;          // ES6
  Decimal.max = max;
  Decimal.min = min;
  Decimal.mod = mod;
  Decimal.mul = mul;
  Decimal.pow = pow;
  Decimal.random = random;
  Decimal.round = round;
  Decimal.sign = sign;          // ES6
  Decimal.sin = sin;
  Decimal.sinh = sinh;          // ES6
  Decimal.sqrt = sqrt;
  Decimal.sub = sub;
  Decimal.tan = tan;
  Decimal.tanh = tanh;          // ES6
  Decimal.trunc = trunc;        // ES6

  if (obj === void 0) obj = {};
  if (obj) {
    ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
    for (i = 0; i &lt; ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
  }

  Decimal.config(obj);

  return Decimal;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
applies to all Decimal numbers created from it.

```js
// Set the precision and rounding of the default Decimal constructor
Decimal.set({ precision: 5, rounding: 4 })

// Create another Decimal constructor, optionally passing in a configuration object
Decimal10 = Decimal.<span class="apidocCodeKeywordSpan">clone</span>({ precision: 10, rounding: 1 })

x = new Decimal(5)
y = new Decimal10(5)

x.div(3)                           // '1.6667'
y.div(3)                           // '1.666666666'
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.config" id="apidoc.element.decimal.js.Decimal.config">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>config
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(obj) {
  if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
  var i, p, v,
    ps = [
      'precision', 1, MAX_DIGITS,
      'rounding', 0, 8,
      'toExpNeg', -EXP_LIMIT, 0,
      'toExpPos', 0, EXP_LIMIT,
      'maxE', 0, EXP_LIMIT,
      'minE', -EXP_LIMIT, 0,
      'modulo', 0, 9
    ];

  for (i = 0; i &lt; ps.length; i += 3) {
    if ((v = obj[p = ps[i]]) !== void 0) {
      if (mathfloor(v) === v &amp;&amp; v &gt;= ps[i + 1] &amp;&amp; v &lt;= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ': ' + v);
    }
  }

  if ((v = obj[p = 'crypto']) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != 'undefined' &amp;&amp; crypto &amp;&amp;
          (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ': ' + v);
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // The initial configuration properties of the Decimal constructor.
    Decimal = {

// These values must be integers within the stated ranges (inclusive).
// Most of these values can be changed at run-time using the `Decimal.config` method.

// The maximum number of significant digits of the result of a calculation or base conversion.
// E.g. `Decimal.<span class="apidocCodeKeywordSpan">config</span>({ precision: 20 });`
precision: 20,                         // 1 to MAX_DIGITS

// The rounding mode used when rounding to `precision`.
//
// ROUND_UP         0 Away from zero.
// ROUND_DOWN       1 Towards zero.
// ROUND_CEIL       2 Towards +Infinity.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.cos" id="apidoc.element.decimal.js.Decimal.cos">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>cos
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cos(x) {
  return new this(x).cos();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function cos(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">cos</span>();
}


/*
 * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
 * significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.cosh" id="apidoc.element.decimal.js.Decimal.cosh">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>cosh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cosh(x) {
  return new this(x).cosh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;

  return divide(x.sinh(), x.<span class="apidocCodeKeywordSpan">cosh</span>(), Ctor.precision = pr, Ctor.rounding = rm);
};


/*
 * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
 * this Decimal.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.default" id="apidoc.element.decimal.js.Decimal.default">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>default
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Decimal(v) {
  var e, i, t,
    x = this;

  // Decimal called without new.
  if (!(x instanceof Decimal)) return new Decimal(v);

  // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
  // which points to Object.
  x.constructor = Decimal;

  // Duplicate.
  if (v instanceof Decimal) {
    x.s = v.s;
    x.e = v.e;
    x.d = (v = v.d) ? v.slice() : v;
    return;
  }

  t = typeof v;

  if (t === 'number') {
    if (v === 0) {
      x.s = 1 / v &lt; 0 ? -1 : 1;
      x.e = 0;
      x.d = [0];
      return;
    }

    if (v &lt; 0) {
      v = -v;
      x.s = -1;
    } else {
      x.s = 1;
    }

    // Fast path for small integers.
    if (v === ~~v &amp;&amp; v &lt; 1e7) {
      for (e = 0, i = v; i &gt;= 10; i /= 10) e++;
      x.e = e;
      x.d = [v];
      return;

    // Infinity, NaN.
    } else if (v * 0 !== 0) {
      if (!v) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return;
    }

    return parseDecimal(x, v.toString());

  } else if (t !== 'string') {
    throw Error(invalidArgument + v);
  }

  // Minus sign?
  if (v.charCodeAt(0) === 45) {
    v = v.slice(1);
    x.s = -1;
  } else {
    x.s = 1;
  }

  return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.div" id="apidoc.element.decimal.js.Decimal.div">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>div
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function div(x, y) {
  return new this(x).div(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().<span class="apidocCodeKeywordSpan">div</span>(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.exp" id="apidoc.element.decimal.js.Decimal.exp">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>exp
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exp(x) {
  return new this(x).exp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Previously, the argument was initially reduced by
* exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
* to first put r in the range [0, ln10], before dividing by 32 until |x| &lt; 0.1, but this was
* found to be slower than just dividing repeatedly by 32 as above.
*
* Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
* Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
* (Math object integer min/max: Math.<span class="apidocCodeKeywordSpan">exp</span>(709) = 8.2e+307, Math.exp(-745) = 5e-324)
*
*  exp(Infinity)  = Infinity
*  exp(-Infinity) = 0
*  exp(NaN)       = NaN
*  exp(0)        = 1
*
*  exp(x) is non-terminating for any finite, non-zero x.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.floor" id="apidoc.element.decimal.js.Decimal.floor">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>floor
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.minus(0.1)                  // '0.2'
x                             // '0.3'
```

The methods that return a Decimal can be chained.

```js
x.dividedBy(y).plus(z).times(9).<span class="apidocCodeKeywordSpan">floor</span>()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.hypot" id="apidoc.element.decimal.js.Decimal.hypot">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>hypot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hypot() {
  var i, n,
    t = new this(0);

  external = false;

  for (i = 0; i &lt; arguments.length;) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }

  external = true;

  return t.sqrt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.ln" id="apidoc.element.decimal.js.Decimal.ln">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>ln
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ln(x) {
  return new this(x).ln();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  x = x.times(x).minus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.<span class="apidocCodeKeywordSpan">ln</span>();
};


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
 * of this Decimal.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.log" id="apidoc.element.decimal.js.Decimal.log">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>log
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log(x, y) {
  return new this(x).log(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Estimate result exponent.
// x^y = 10^e,  where e = y * log10(x)
// log10(x) = log10(x_significand) + x_exponent
// log10(x_significand) = ln(x_significand) / ln(10)
k = mathpow(+x, yn);
e = k == 0 || !isFinite(k)
  ? mathfloor(yn * (Math.<span class="apidocCodeKeywordSpan">log</span>('0.' + digitsToString(x.d)) / Math.LN10 + x.e +
1))
  : new Ctor(k + '').e;

// Estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

// Overflow/underflow?
if (e &gt; Ctor.maxE + 1 || e &lt; Ctor.minE - 1) return new Ctor(e &gt; 0 ? sign / 0 : 0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.log10" id="apidoc.element.decimal.js.Decimal.log10">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>log10
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log10(x) {
  return new this(x).log(10);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.log2" id="apidoc.element.decimal.js.Decimal.log2">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>log2
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log2(x) {
  return new this(x).log(2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.max" id="apidoc.element.decimal.js.Decimal.max">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>max
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function max() {
  return maxOrMin(this, arguments, 'lt');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!x.d) return new Ctor(NaN);

// cos(0) = cos(-0) = 1
if (!x.d[0]) return new Ctor(1);

pr = Ctor.precision;
rm = Ctor.rounding;
Ctor.precision = pr + Math.<span class="apidocCodeKeywordSpan">max</span>(x.e, x.sd()) + LOG_BASE;
Ctor.rounding = 1;

x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

Ctor.precision = pr;
Ctor.rounding = rm;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.min" id="apidoc.element.decimal.js.Decimal.min">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>min
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min() {
  return maxOrMin(this, arguments, 'gt');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// TODO? if (x &gt;= 1 &amp;&amp; pr &lt;= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

// Argument reduction
// Ensure |x| &lt; 0.42
// atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

k = Math.<span class="apidocCodeKeywordSpan">min</span>(28, wpr / LOG_BASE + 2 | 0);

for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

external = false;

j = Math.ceil(wpr / LOG_BASE);
n = 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.mod" id="apidoc.element.decimal.js.Decimal.mod">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>mod
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mod(x, y) {
  return new this(x).mod(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.<span class="apidocCodeKeywordSpan">mod</span>(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        //
true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
x.toExponential(5)              // '2.55500e+2'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.mul" id="apidoc.element.decimal.js.Decimal.mul">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>mul
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mul(x, y) {
  return new this(x).mul(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function mul(x, y) {
  return new this(x).<span class="apidocCodeKeywordSpan">mul</span>(y);
}


/*
 * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
 * significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.pow" id="apidoc.element.decimal.js.Decimal.pow">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>pow
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pow(x, y) {
  return new this(x).pow(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).<span class="apidocCodeKeywordSpan">pow</span>(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.random" id="apidoc.element.decimal.js.Decimal.random">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>random
        <span class="apidocSignatureSpan">(sd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function random(sd) {
  var d, e, k, n,
    i = 0,
    r = new this(1),
    rd = [];

  if (sd === void 0) sd = this.precision;
  else checkInt32(sd, 1, MAX_DIGITS);

  k = Math.ceil(sd / LOG_BASE);

  if (!this.crypto) {
    for (; i &lt; k;) rd[i++] = Math.random() * 1e7 | 0;

  // Browsers supporting crypto.getRandomValues.
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));

    for (; i &lt; k;) {
      n = d[i];

      // 0 &lt;= n &lt; 4294967296
      // Probability n &gt;= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
      if (n &gt;= 4.29e9) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {

        // 0 &lt;= n &lt;= 4289999999
        // 0 &lt;= (n % 1e7) &lt;= 9999999
        rd[i++] = n % 1e7;
      }
    }

  // Node.js supporting crypto.randomBytes.
  } else if (crypto.randomBytes) {

    // buffer
    d = crypto.randomBytes(k *= 4);

    for (; i &lt; k;) {

      // 0 &lt;= n &lt; 2147483648
      n = d[i] + (d[i + 1] &lt;&lt; 8) + (d[i + 2] &lt;&lt; 16) + ((d[i + 3] &amp; 0x7f) &lt;&lt; 24);

      // Probability n &gt;= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
      if (n &gt;= 2.14e9) {
        crypto.randomBytes(4).copy(d, i);
      } else {

        // 0 &lt;= n &lt;= 2139999999
        // 0 &lt;= (n % 1e7) &lt;= 9999999
        rd.push(n % 1e7);
        i += 4;
      }
    }

    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }

  k = rd[--i];
  sd %= LOG_BASE;

  // Convert trailing digits to zeros according to sd.
  if (k &amp;&amp; sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }

  // Remove trailing words which are zero.
  for (; rd[i] === 0; i--) rd.pop();

  // Zero?
  if (i &lt; 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;

    // Remove leading words which are zero and adjust exponent accordingly.
    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

    // Count the digits of the first word of rd to determine leading zeros.
    for (k = 1, n = rd[0]; n &gt;= 10; n /= 10) k++;

    // Adjust the exponent for leading zeros of the first word of rd.
    if (k &lt; LOG_BASE) e -= LOG_BASE - k;
  }

  r.e = e;
  r.d = rd;

  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if (sd === void 0) sd = this.precision;
    else checkInt32(sd, 1, MAX_DIGITS);

    k = Math.ceil(sd / LOG_BASE);

    if (!this.crypto) {
for (; i &lt; k;) rd[i++] = Math.<span class="apidocCodeKeywordSpan">random</span>() * 1e7 | 0;

    // Browsers supporting crypto.getRandomValues.
    } else if (crypto.getRandomValues) {
d = crypto.getRandomValues(new Uint32Array(k));

for (; i &lt; k;) {
  n = d[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.round" id="apidoc.element.decimal.js.Decimal.round">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>round
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.set" id="apidoc.element.decimal.js.Decimal.set">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>set
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function config(obj) {
  if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
  var i, p, v,
    ps = [
      'precision', 1, MAX_DIGITS,
      'rounding', 0, 8,
      'toExpNeg', -EXP_LIMIT, 0,
      'toExpPos', 0, EXP_LIMIT,
      'maxE', 0, EXP_LIMIT,
      'minE', -EXP_LIMIT, 0,
      'modulo', 0, 9
    ];

  for (i = 0; i &lt; ps.length; i += 3) {
    if ((v = obj[p = ps[i]]) !== void 0) {
      if (mathfloor(v) === v &amp;&amp; v &gt;= ps[i + 1] &amp;&amp; v &lt;= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ': ' + v);
    }
  }

  if ((v = obj[p = 'crypto']) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != 'undefined' &amp;&amp; crypto &amp;&amp;
          (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ': ' + v);
    }
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
specified by the `precision` and `rounding` properties of the Decimal constructor.

Multiple Decimal constructors can be created, each with their own independent configuration which
applies to all Decimal numbers created from it.

```js
// Set the precision and rounding of the default Decimal constructor
Decimal.<span class="apidocCodeKeywordSpan">set</span>({ precision: 5, rounding: 4 })

// Create another Decimal constructor, optionally passing in a configuration object
Decimal10 = Decimal.clone({ precision: 10, rounding: 1 })

x = new Decimal(5)
y = new Decimal10(5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.sign" id="apidoc.element.decimal.js.Decimal.sign">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>sign
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(x) {
  x = new this(x);
  return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.sin" id="apidoc.element.decimal.js.Decimal.sin">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>sin
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sin(x) {
  return new this(x).sin();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (x.isZero()) return new Ctor(x);

pr = Ctor.precision;
rm = Ctor.rounding;
Ctor.precision = pr + 10;
Ctor.rounding = 1;

x = x.<span class="apidocCodeKeywordSpan">sin</span>();
x.s = 1;
x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

Ctor.precision = pr;
Ctor.rounding = rm;

return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.sinh" id="apidoc.element.decimal.js.Decimal.sinh">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>sinh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sinh(x) {
  return new this(x).sinh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;

  return divide(x.<span class="apidocCodeKeywordSpan">sinh</span>(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};


/*
 * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
 * this Decimal.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.sqrt" id="apidoc.element.decimal.js.Decimal.sqrt">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>sqrt
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sqrt(x) {
  return new this(x).sqrt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.<span class="apidocCodeKeywordSpan">sqrt</span>().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.sub" id="apidoc.element.decimal.js.Decimal.sub">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>sub
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sub(x, y) {
  return new this(x).sub(y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function sub(x, y) {
  return new this(x).<span class="apidocCodeKeywordSpan">sub</span>(y);
}


/*
 * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.tan" id="apidoc.element.decimal.js.Decimal.tan">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>tan
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tan(x) {
  return new this(x).tan();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function tan(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">tan</span>();
}


/*
 * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.tanh" id="apidoc.element.decimal.js.Decimal.tanh">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>tanh
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tanh(x) {
  return new this(x).tanh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function tanh(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">tanh</span>();
}


/*
 * Return a new Decimal whose value is `x` truncated to an integer.
 *
 * x {number|string|Decimal}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.trunc" id="apidoc.element.decimal.js.Decimal.trunc">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.</span>trunc
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.decimal.js.Decimal.prototype" id="apidoc.module.decimal.js.Decimal.prototype">module decimal.js.Decimal.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.abs" id="apidoc.element.decimal.js.Decimal.prototype.abs">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>abs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abs = function () {
  var x = new this.constructor(this);
  if (x.s &lt; 0) x.s = 1;
  return finalise(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    external = false;

    // Initial estimate.
    s = x.s * Math.pow(x.s * x, 1 / 3);

     // Math.cbrt underflow/overflow?
     // Pass x to Math.pow as integer, then adjust the exponent of the result.
    if (!s || Math.<span class="apidocCodeKeywordSpan">abs</span>(s) == 1 / 0) {
n = digitsToString(x.d);
e = x.e;

// Adjust n exponent so it is a multiple of 3 away from x exponent.
if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
s = Math.pow(n, 1 / 3);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.absoluteValue" id="apidoc.element.decimal.js.Decimal.prototype.absoluteValue">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>absoluteValue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">absoluteValue = function () {
  var x = new this.constructor(this);
  if (x.s &lt; 0) x.s = 1;
  return finalise(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.acos" id="apidoc.element.decimal.js.Decimal.prototype.acos">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>acos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acos = function () {
  var halfPi,
    x = this,
    Ctor = x.constructor,
    k = x.abs().cmp(1),
    pr = Ctor.precision,
    rm = Ctor.rounding;

  if (k !== -1) {
    return k === 0
      // |x| is 1
      ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
      // |x| &gt; 1 or x is NaN
      : new Ctor(NaN);
  }

  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

  // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return halfPi.minus(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*
 * Return a new Decimal whose value is the arccosine in radians of `x`.
 *
 * x {number|string|Decimal}
 *
 */
function acos(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">acos</span>();
}


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.acosh" id="apidoc.element.decimal.js.Decimal.prototype.acosh">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>acosh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acosh = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;

  x = x.times(x).minus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.ln();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function acosh(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">acosh</span>();
}


/*
 * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.add" id="apidoc.element.decimal.js.Decimal.prototype.add">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>add
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // If either is not finite...
  if (!x.d || !y.d) {

    // Return NaN if either is NaN.
    if (!x.s || !y.s) y = new Ctor(NaN);

    // Return x if y is finite and x is Infinity.
    // Return x if both are Infinity with the same sign.
    // Return NaN if both are Infinity with different signs.
    // Return y if x is finite and y is Infinity.
    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

    return y;
  }

   // If signs differ...
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }

  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;

  // If either is zero...
  if (!xd[0] || !yd[0]) {

    // Return x if y is zero.
    // Return y if y is non-zero.
    if (!yd[0]) y = new Ctor(x);

    return external ? finalise(y, pr, rm) : y;
  }

  // x and y are finite, non-zero numbers with the same sign.

  // Calculate base 1e7 exponents.
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);

  xd = xd.slice();
  i = k - e;

  // If base 1e7 exponents differ...
  if (i) {

    if (i &lt; 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }

    // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
    k = Math.ceil(pr / LOG_BASE);
    len = k &gt; len ? k + 1 : len + 1;

    if (i &gt; len) {
      i = len;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
    d.reverse();
    for (; i--;) d.push(0);
    d.reverse();
  }

  len = xd.length;
  i = yd.length;

  // If yd is longer than xd, swap xd and yd so xd points to the longer array.
  if (len - i &lt; 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }

  // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
  for (carry = 0; i;) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }

  if (carry) {
    xd.unshift(carry);
    ++e;
  }

  // Remove trailing zeros.
  // No need to check for zero, as +x + +y != 0 &amp;&amp; -x + -y != 0
  for (len = xd.length; xd[--len] == 0;) xd.pop();

  y.d = xd;
  y.e = getBase10Exponent(xd, e);

  return external ? finalise(y, pr, rm) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.asin" id="apidoc.element.decimal.js.Decimal.prototype.asin">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>asin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asin = function () {
  var halfPi, k,
    pr, rm,
    x = this,
    Ctor = x.constructor;

  if (x.isZero()) return new Ctor(x);

  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;

  if (k !== -1) {

    // |x| is 1
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }

    // |x| &gt; 1 or x is NaN
    return new Ctor(NaN);
  }

  // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

  // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.<span class="apidocCodeKeywordSpan">asin</span>();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return halfPi.minus(x);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.asinh" id="apidoc.element.decimal.js.Decimal.prototype.asinh">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>asinh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asinh = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;

  x = x.times(x).plus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.ln();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function asinh(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">asinh</span>();
}


/*
 * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.atan" id="apidoc.element.decimal.js.Decimal.prototype.atan">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>atan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atan = function () {
  var i, j, k, n, px, t, r, wpr, x2,
    x = this,
    Ctor = x.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding;

  if (!x.isFinite()) {
    if (!x.s) return new Ctor(NaN);
    if (pr + 4 &lt;= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) &amp;&amp; pr + 4 &lt;= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }

  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;

  // TODO? if (x &gt;= 1 &amp;&amp; pr &lt;= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

  // Argument reduction
  // Ensure |x| &lt; 0.42
  // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

  k = Math.min(28, wpr / LOG_BASE + 2 | 0);

  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

  external = false;

  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;

  // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
  for (; i !== -1;) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));

    px = px.times(x2);
    r = t.plus(px.div(n += 2));

    if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] &amp;&amp; i--;);
  }

  if (k) r = r.times(2 &lt;&lt; (k - 1));

  external = true;

  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).<span class="apidocCodeKeywordSpan">atan</span>();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(2);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.atanh" id="apidoc.element.decimal.js.Decimal.prototype.atanh">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>atanh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">atanh = function () {
  var pr, rm, wpr, xsd,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.e &gt;= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();

  if (Math.max(xsd, pr) &lt; 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

  Ctor.precision = wpr = xsd - x.e;

  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

  Ctor.precision = pr + 4;
  Ctor.rounding = 1;

  x = x.ln();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(0.5);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function atanh(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">atanh</span>();
}


/*
 * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
 * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.cbrt" id="apidoc.element.decimal.js.Decimal.prototype.cbrt">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>cbrt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cbrt = function () {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  external = false;

  // Initial estimate.
  s = x.s * Math.pow(x.s * x, 1 / 3);

   // Math.cbrt underflow/overflow?
   // Pass x to Math.pow as integer, then adjust the exponent of the result.
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;

    // Adjust n exponent so it is a multiple of 3 away from x exponent.
    if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
    s = Math.pow(n, 1 / 3);

    // Rarely, e may be one less than the result exponent value.
    e = mathfloor((e + 1) / 3) - (e % 3 == (e &lt; 0 ? -1 : 2));

    if (s == 1 / 0) {
      n = '5e' + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf('e') + 1) + e;
    }

    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }

  sd = (e = Ctor.precision) + 3;

  // Halley's method.
  // TODO? Compare Newton's method.
  for (;;) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

    // TODO? Replace with for-loop and checkRoundingDigits.
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);

      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
      // , i.e. approaching a rounding boundary, continue the iteration.
      if (n == '9999' || !rep &amp;&amp; n == '4999') {

        // On the first iteration only, check to see if rounding up gives the exact result as the
        // nines may infinitely repeat.
        if (!rep) {
          finalise(t, e + 1, 0);

          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }

        sd += 4;
        rep = 1;
      } else {

        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
        // If not, then there are further digits and m will be truthy.
        if (!+n || !+n.slice(1) &amp;&amp; n.charAt(0) == '5') {

          // Truncate to the first rounding digit.
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }

        break;
      }
    }
  }

  external = true;

  return finalise(r, e, Ctor.rounding, m);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *  cbrt(-0) = -0
 *  cbrt(1)  =  1
 *  cbrt(-1) = -1
 *  cbrt(N)  =  N
 *  cbrt(-I) = -I
 *  cbrt(I)  =  I
 *
 * Math.<span class="apidocCodeKeywordSpan">cbrt</span>(x) = (x &lt; 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
 *
 */
P.cubeRoot = P.cbrt = function () {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx,
    x = this,
    Ctor = x.constructor;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.ceil" id="apidoc.element.decimal.js.Decimal.prototype.ceil">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>ceil
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ceil = function () {
  return finalise(new this.constructor(this), this.e + 1, 2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x                             // '0.3'
```

The methods that return a Decimal can be chained.

```js
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').<span class="apidocCodeKeywordSpan
">ceil</span>()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.cmp" id="apidoc.element.decimal.js.Decimal.prototype.cmp">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>cmp
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cmp = function (y) {
  var i, j, xdL, ydL,
    x = this,
    xd = x.d,
    yd = (y = new x.constructor(y)).d,
    xs = x.s,
    ys = y.s;

  // Either NaN or Infinity?
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs &lt; 0 ? 1 : -1;
  }

  // Either zero?
  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

  // Signs differ?
  if (xs !== ys) return xs;

  // Compare exponents.
  if (x.e !== y.e) return x.e &gt; y.e ^ xs &lt; 0 ? 1 : -1;

  xdL = xd.length;
  ydL = yd.length;

  // Compare digit by digit.
  for (i = 0, j = xdL &lt; ydL ? xdL : ydL; i &lt; j; ++i) {
    if (xd[i] !== yd[i]) return xd[i] &gt; yd[i] ^ xs &lt; 0 ? 1 : -1;
  }

  // Compare lengths.
  return xdL === ydL ? 0 : xdL &gt; ydL ^ xs &lt; 0 ? 1 : -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.<span class="apidocCodeKeywordSpan">cmp</span>(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        //
true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
x.toExponential(5)              // '2.55500e+2'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.comparedTo" id="apidoc.element.decimal.js.Decimal.prototype.comparedTo">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>comparedTo
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comparedTo = function (y) {
  var i, j, xdL, ydL,
    x = this,
    xd = x.d,
    yd = (y = new x.constructor(y)).d,
    xs = x.s,
    ys = y.s;

  // Either NaN or Infinity?
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs &lt; 0 ? 1 : -1;
  }

  // Either zero?
  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

  // Signs differ?
  if (xs !== ys) return xs;

  // Compare exponents.
  if (x.e !== y.e) return x.e &gt; y.e ^ xs &lt; 0 ? 1 : -1;

  xdL = xd.length;
  ydL = yd.length;

  // Compare digit by digit.
  for (i = 0, j = xdL &lt; ydL ? xdL : ydL; i &lt; j; ++i) {
    if (xd[i] !== yd[i]) return xd[i] &gt; yd[i] ^ xs &lt; 0 ? 1 : -1;
  }

  // Compare lengths.
  return xdL === ydL ? 0 : xdL &gt; ydL ^ xs &lt; 0 ? 1 : -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.<span class="apidocCodeKeywordSpan">comparedTo</span>(y.modulo(z).negated()) == 1        //
true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
x.toExponential(5)              // '2.55500e+2'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.cos" id="apidoc.element.decimal.js.Decimal.prototype.cos">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>cos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cos = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.d) return new Ctor(NaN);

  // cos(0) = cos(-0) = 1
  if (!x.d[0]) return new Ctor(1);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;

  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function cos(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">cos</span>();
}


/*
 * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
 * significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.cosh" id="apidoc.element.decimal.js.Decimal.prototype.cosh">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>cosh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cosh = function () {
  var k, n, pr, rm, len,
    x = this,
    Ctor = x.constructor,
    one = new Ctor(1);

  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero()) return one;

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;

  // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
  // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

  // Estimate the optimum number of times to use the argument reduction.
  // TODO? Estimation reused from cosine() and may not be optimal here.
  if (len &lt; 32) {
    k = Math.ceil(len / 3);
    n = Math.pow(4, -k).toString();
  } else {
    k = 16;
    n = '2.3283064365386962890625e-10';
  }

  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

  // Reverse argument reduction
  var cosh2_x,
    i = k,
    d8 = new Ctor(8);
  for (; i--;) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }

  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;

  return divide(x.sinh(), x.<span class="apidocCodeKeywordSpan">cosh</span>(), Ctor.precision = pr, Ctor.rounding = rm);
};


/*
 * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
 * this Decimal.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.cosine" id="apidoc.element.decimal.js.Decimal.prototype.cosine">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>cosine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cosine = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.d) return new Ctor(NaN);

  // cos(0) = cos(-0) = 1
  if (!x.d[0]) return new Ctor(1);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;

  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.cubeRoot" id="apidoc.element.decimal.js.Decimal.prototype.cubeRoot">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>cubeRoot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cubeRoot = function () {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  external = false;

  // Initial estimate.
  s = x.s * Math.pow(x.s * x, 1 / 3);

   // Math.cbrt underflow/overflow?
   // Pass x to Math.pow as integer, then adjust the exponent of the result.
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;

    // Adjust n exponent so it is a multiple of 3 away from x exponent.
    if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
    s = Math.pow(n, 1 / 3);

    // Rarely, e may be one less than the result exponent value.
    e = mathfloor((e + 1) / 3) - (e % 3 == (e &lt; 0 ? -1 : 2));

    if (s == 1 / 0) {
      n = '5e' + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf('e') + 1) + e;
    }

    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }

  sd = (e = Ctor.precision) + 3;

  // Halley's method.
  // TODO? Compare Newton's method.
  for (;;) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

    // TODO? Replace with for-loop and checkRoundingDigits.
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);

      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
      // , i.e. approaching a rounding boundary, continue the iteration.
      if (n == '9999' || !rep &amp;&amp; n == '4999') {

        // On the first iteration only, check to see if rounding up gives the exact result as the
        // nines may infinitely repeat.
        if (!rep) {
          finalise(t, e + 1, 0);

          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }

        sd += 4;
        rep = 1;
      } else {

        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
        // If not, then there are further digits and m will be truthy.
        if (!+n || !+n.slice(1) &amp;&amp; n.charAt(0) == '5') {

          // Truncate to the first rounding digit.
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }

        break;
      }
    }
  }

  external = true;

  return finalise(r, e, Ctor.rounding, m);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.decimalPlaces" id="apidoc.element.decimal.js.Decimal.prototype.decimalPlaces">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>decimalPlaces
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decimalPlaces = function () {
  var w,
    d = this.d,
    n = NaN;

  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

    // Subtract the number of trailing zeros of the last word.
    w = d[w];
    if (w) for (; w % 10 == 0; w /= 10) n--;
    if (n &lt; 0) n = 0;
  }

  return n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.div" id="apidoc.element.decimal.js.Decimal.prototype.div">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>div
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">div = function (y) {
  return divide(this, new this.constructor(y));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().<span class="apidocCodeKeywordSpan">div</span>(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.divToInt" id="apidoc.element.decimal.js.Decimal.prototype.divToInt">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>divToInt
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">divToInt = function (y) {
  var x = this,
    Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    x = x.abs();

    if (x.lte(halfPi)) {
quadrant = isNeg ? 4 : 1;
return x;
    }

    t = x.<span class="apidocCodeKeywordSpan">divToInt</span>(pi);

    if (t.isZero()) {
quadrant = isNeg ? 3 : 2;
    } else {
x = x.minus(t.times(pi));

// 0 &lt;= x &lt; pi
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.dividedBy" id="apidoc.element.decimal.js.Decimal.prototype.dividedBy">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>dividedBy
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dividedBy = function (y) {
  return divide(this, new this.constructor(y));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.minus(0.1)                  // '0.2'
x                             // '0.3'
```

The methods that return a Decimal can be chained.

```js
x.<span class="apidocCodeKeywordSpan">dividedBy</span>(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.dividedToIntegerBy" id="apidoc.element.decimal.js.Decimal.prototype.dividedToIntegerBy">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>dividedToIntegerBy
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dividedToIntegerBy = function (y) {
  var x = this,
    Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.dp" id="apidoc.element.decimal.js.Decimal.prototype.dp">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>dp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dp = function () {
  var w,
    d = this.d,
    n = NaN;

  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

    // Subtract the number of trailing zeros of the last word.
    w = d[w];
    if (w) for (; w % 10 == 0; w /= 10) n--;
    if (n &lt; 0) n = 0;
  }

  return n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.eq" id="apidoc.element.decimal.js.Decimal.prototype.eq">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>eq
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eq = function (y) {
  return this.cmp(y) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (n == '9999' || !rep &amp;&amp; n == '4999') {

// On the first iteration only, check to see if rounding up gives the exact result as the
// nines may infinitely repeat.
if (!rep) {
  finalise(t, e + 1, 0);

  if (t.times(t).times(t).<span class="apidocCodeKeywordSpan">eq</span>(x)) {
    r = t;
    break;
  }
}

sd += 4;
rep = 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.equals" id="apidoc.element.decimal.js.Decimal.prototype.equals">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>equals
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (y) {
  return this.cmp(y) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

It accepts a value of type number, string or Decimal.

```js
x = new Decimal(123.4567)
y = new Decimal('123456.7e-3')
z = new Decimal(x)
x.<span class="apidocCodeKeywordSpan">equals</span>(y) &amp;&amp; y.equals(z) &amp;&amp; x.equals(z)        // true
```

A value can also be in binary, hexadecimal or octal if the appropriate prefix is included.

```js
x = new Decimal('0xff.f')            // '255.9375'
y = new Decimal('0b10101100')        // '172'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.exp" id="apidoc.element.decimal.js.Decimal.prototype.exp">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>exp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exp = function () {
  return naturalExponential(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Previously, the argument was initially reduced by
* exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
* to first put r in the range [0, ln10], before dividing by 32 until |x| &lt; 0.1, but this was
* found to be slower than just dividing repeatedly by 32 as above.
*
* Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
* Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
* (Math object integer min/max: Math.<span class="apidocCodeKeywordSpan">exp</span>(709) = 8.2e+307, Math.exp(-745) = 5e-324)
*
*  exp(Infinity)  = Infinity
*  exp(-Infinity) = 0
*  exp(NaN)       = NaN
*  exp(0)        = 1
*
*  exp(x) is non-terminating for any finite, non-zero x.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.floor" id="apidoc.element.decimal.js.Decimal.prototype.floor">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>floor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">floor = function () {
  return finalise(new this.constructor(this), this.e + 1, 3);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.minus(0.1)                  // '0.2'
x                             // '0.3'
```

The methods that return a Decimal can be chained.

```js
x.dividedBy(y).plus(z).times(9).<span class="apidocCodeKeywordSpan">floor</span>()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.greaterThan" id="apidoc.element.decimal.js.Decimal.prototype.greaterThan">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>greaterThan
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greaterThan = function (y) {
  return this.cmp(y) &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.greaterThanOrEqualTo" id="apidoc.element.decimal.js.Decimal.prototype.greaterThanOrEqualTo">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>greaterThanOrEqualTo
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">greaterThanOrEqualTo = function (y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.gt" id="apidoc.element.decimal.js.Decimal.prototype.gt">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>gt
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gt = function (y) {
  return this.cmp(y) &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (maxD == null) {

  // d is 10**e, the minimum max-denominator needed.
  maxD = e &gt; 0 ? d : n1;
} else {
  n = new Ctor(maxD);
  if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
  maxD = n.<span class="apidocCodeKeywordSpan">gt</span>(d) ? (e &gt; 0 ? d : n1) : n;
}

external = false;
n = new Ctor(digitsToString(xd));
pr = Ctor.precision;
Ctor.precision = e = xd.length * LOG_BASE * 2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.gte" id="apidoc.element.decimal.js.Decimal.prototype.gte">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>gte
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gte = function (y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.hyperbolicCosine" id="apidoc.element.decimal.js.Decimal.prototype.hyperbolicCosine">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>hyperbolicCosine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hyperbolicCosine = function () {
  var k, n, pr, rm, len,
    x = this,
    Ctor = x.constructor,
    one = new Ctor(1);

  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero()) return one;

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;

  // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
  // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

  // Estimate the optimum number of times to use the argument reduction.
  // TODO? Estimation reused from cosine() and may not be optimal here.
  if (len &lt; 32) {
    k = Math.ceil(len / 3);
    n = Math.pow(4, -k).toString();
  } else {
    k = 16;
    n = '2.3283064365386962890625e-10';
  }

  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

  // Reverse argument reduction
  var cosh2_x,
    i = k,
    d8 = new Ctor(8);
  for (; i--;) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }

  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.hyperbolicSine" id="apidoc.element.decimal.js.Decimal.prototype.hyperbolicSine">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>hyperbolicSine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hyperbolicSine = function () {
  var k, pr, rm, len,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;

  if (len &lt; 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {

    // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
    // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
    // 3 multiplications and 1 addition

    // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
    // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
    // 4 multiplications and 2 additions

    // Estimate the optimum number of times to use the argument reduction.
    k = 1.4 * Math.sqrt(len);
    k = k &gt; 16 ? 16 : k | 0;

    x = x.times(Math.pow(5, -k));

    x = taylorSeries(Ctor, 2, x, x, true);

    // Reverse argument reduction
    var sinh2_x,
      d5 = new Ctor(5),
      d16 = new Ctor(16),
      d20 = new Ctor(20);
    for (; k--;) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.hyperbolicTangent" id="apidoc.element.decimal.js.Decimal.prototype.hyperbolicTangent">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>hyperbolicTangent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hyperbolicTangent = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(x.s);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;

  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.inverseCosine" id="apidoc.element.decimal.js.Decimal.prototype.inverseCosine">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>inverseCosine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverseCosine = function () {
  var halfPi,
    x = this,
    Ctor = x.constructor,
    k = x.abs().cmp(1),
    pr = Ctor.precision,
    rm = Ctor.rounding;

  if (k !== -1) {
    return k === 0
      // |x| is 1
      ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
      // |x| &gt; 1 or x is NaN
      : new Ctor(NaN);
  }

  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

  // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return halfPi.minus(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.inverseHyperbolicCosine" id="apidoc.element.decimal.js.Decimal.prototype.inverseHyperbolicCosine">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>inverseHyperbolicCosine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverseHyperbolicCosine = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;

  x = x.times(x).minus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.ln();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.inverseHyperbolicSine" id="apidoc.element.decimal.js.Decimal.prototype.inverseHyperbolicSine">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>inverseHyperbolicSine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverseHyperbolicSine = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;

  x = x.times(x).plus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.ln();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.inverseHyperbolicTangent" id="apidoc.element.decimal.js.Decimal.prototype.inverseHyperbolicTangent">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>inverseHyperbolicTangent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverseHyperbolicTangent = function () {
  var pr, rm, wpr, xsd,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.e &gt;= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();

  if (Math.max(xsd, pr) &lt; 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

  Ctor.precision = wpr = xsd - x.e;

  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

  Ctor.precision = pr + 4;
  Ctor.rounding = 1;

  x = x.ln();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(0.5);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.inverseSine" id="apidoc.element.decimal.js.Decimal.prototype.inverseSine">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>inverseSine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverseSine = function () {
  var halfPi, k,
    pr, rm,
    x = this,
    Ctor = x.constructor;

  if (x.isZero()) return new Ctor(x);

  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;

  if (k !== -1) {

    // |x| is 1
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }

    // |x| &gt; 1 or x is NaN
    return new Ctor(NaN);
  }

  // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.inverseTangent" id="apidoc.element.decimal.js.Decimal.prototype.inverseTangent">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>inverseTangent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverseTangent = function () {
  var i, j, k, n, px, t, r, wpr, x2,
    x = this,
    Ctor = x.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding;

  if (!x.isFinite()) {
    if (!x.s) return new Ctor(NaN);
    if (pr + 4 &lt;= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) &amp;&amp; pr + 4 &lt;= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }

  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;

  // TODO? if (x &gt;= 1 &amp;&amp; pr &lt;= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

  // Argument reduction
  // Ensure |x| &lt; 0.42
  // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

  k = Math.min(28, wpr / LOG_BASE + 2 | 0);

  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

  external = false;

  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;

  // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
  for (; i !== -1;) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));

    px = px.times(x2);
    r = t.plus(px.div(n += 2));

    if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] &amp;&amp; i--;);
  }

  if (k) r = r.times(2 &lt;&lt; (k - 1));

  external = true;

  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.isFinite" id="apidoc.element.decimal.js.Decimal.prototype.isFinite">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isFinite
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFinite = function () {
  return !!this.d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

There are `isNaN` and `isFinite` methods, as `NaN` and `Infinity` are valid `Decimal` values,

```js
x = new Decimal(NaN)                                           // 'NaN'
y = new Decimal(Infinity)                                      // 'Infinity'
x.isNaN() &amp;&amp; !y.isNaN() &amp;&amp; !x.<span class="apidocCodeKeywordSpan">isFinite</span>() &amp;&amp; !y.isFinite
()      // true
```

and a `toFraction` method with an optional *maximum denominator* argument

```js
z = new Decimal(355)
pi = z.dividedBy(113)        // '3.1415929204'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.isInt" id="apidoc.element.decimal.js.Decimal.prototype.isInt">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isInt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInt = function () {
  return !!this.d &amp;&amp; mathfloor(this.e / LOG_BASE) &gt; this.d.length - 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (maxD == null) {

  // d is 10**e, the minimum max-denominator needed.
  maxD = e &gt; 0 ? d : n1;
} else {
  n = new Ctor(maxD);
  if (!n.<span class="apidocCodeKeywordSpan">isInt</span>() || n.lt(n1)) throw Error(invalidArgument + n);
  maxD = n.gt(d) ? (e &gt; 0 ? d : n1) : n;
}

external = false;
n = new Ctor(digitsToString(xd));
pr = Ctor.precision;
Ctor.precision = e = xd.length * LOG_BASE * 2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.isInteger" id="apidoc.element.decimal.js.Decimal.prototype.isInteger">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isInteger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInteger = function () {
  return !!this.d &amp;&amp; mathfloor(this.e / LOG_BASE) &gt; this.d.length - 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.isNaN" id="apidoc.element.decimal.js.Decimal.prototype.isNaN">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isNaN
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNaN = function () {
  return !this.s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

There are `isNaN` and `isFinite` methods, as `NaN` and `Infinity` are valid `Decimal` values,

```js
x = new Decimal(NaN)                                           // 'NaN'
y = new Decimal(Infinity)                                      // 'Infinity'
x.<span class="apidocCodeKeywordSpan">isNaN</span>() &amp;&amp; !y.isNaN() &amp;&amp; !x.isFinite() &amp;&amp; !y.isFinite
()      // true
```

and a `toFraction` method with an optional *maximum denominator* argument

```js
z = new Decimal(355)
pi = z.dividedBy(113)        // '3.1415929204'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.isNeg" id="apidoc.element.decimal.js.Decimal.prototype.isNeg">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isNeg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNeg = function () {
  return this.s &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  k = x.abs().cmp(1),
  pr = Ctor.precision,
  rm = Ctor.rounding;

if (k !== -1) {
  return k === 0
    // |x| is 1
    ? x.<span class="apidocCodeKeywordSpan">isNeg</span>() ? getPi(Ctor, pr, rm) : new Ctor(0)
    // |x| &gt; 1 or x is NaN
    : new Ctor(NaN);
}

if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

// TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.isNegative" id="apidoc.element.decimal.js.Decimal.prototype.isNegative">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isNegative
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNegative = function () {
  return this.s &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.isPos" id="apidoc.element.decimal.js.Decimal.prototype.isPos">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isPos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPos = function () {
  return this.s &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.isPositive" id="apidoc.element.decimal.js.Decimal.prototype.isPositive">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isPositive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPositive = function () {
  return this.s &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.isZero" id="apidoc.element.decimal.js.Decimal.prototype.isZero">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>isZero
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isZero = function () {
  return !!this.d &amp;&amp; this.d[0] === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   */
  P.cubeRoot = P.cbrt = function () {
    var e, m, n, r, rep, s, sd, t, t3, t3plusx,
 x = this,
 Ctor = x.constructor;

    if (!x.isFinite() || x.<span class="apidocCodeKeywordSpan">isZero</span>()) return new Ctor(x);
    external = false;

    // Initial estimate.
    s = x.s * Math.pow(x.s * x, 1 / 3);

// Math.cbrt underflow/overflow?
// Pass x to Math.pow as integer, then adjust the exponent of the result.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.lessThan" id="apidoc.element.decimal.js.Decimal.prototype.lessThan">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>lessThan
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lessThan = function (y) {
  return this.cmp(y) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.lessThanOrEqualTo" id="apidoc.element.decimal.js.Decimal.prototype.lessThanOrEqualTo">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>lessThanOrEqualTo
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lessThanOrEqualTo = function (y) {
  return this.cmp(y) &lt; 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.ln" id="apidoc.element.decimal.js.Decimal.prototype.ln">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>ln
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ln = function () {
  return naturalLogarithm(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  x = x.times(x).minus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.<span class="apidocCodeKeywordSpan">ln</span>();
};


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
 * of this Decimal.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.log" id="apidoc.element.decimal.js.Decimal.prototype.log">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>log
        <span class="apidocSignatureSpan">(base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (base) {
  var isBase10, d, denominator, k, inf, num, sd, r,
    arg = this,
    Ctor = arg.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding,
    guard = 5;

  // Default base is 10.
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;

    // Return NaN if base is negative, or non-finite, or is 0 or 1.
    if (base.s &lt; 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

    isBase10 = base.eq(10);
  }

  d = arg.d;

  // Is arg negative, non-finite, 0 or 1?
  if (arg.s &lt; 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d &amp;&amp; !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }

  // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
  // integer power of 10.
  if (isBase10) {
    if (d.length &gt; 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0;) k /= 10;
      inf = k !== 1;
    }
  }

  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

  // The result will have 5 rounding digits.
  r = divide(num, denominator, sd, 1);

  // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
  // calculate 10 further digits.
  //
  // If the result is known to have an infinite decimal expansion, repeat this until it is clear
  // that the result is above or below the boundary. Otherwise, if after calculating the 10
  // further digits, the last 14 are nines, round up and assume the result is exact.
  // Also assume the result is exact if the last 14 are zero.
  //
  // Example of a result that will be incorrectly rounded:
  // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
  // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
  // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
  // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
  // place is still 2.6.
  if (checkRoundingDigits(r.d, k = pr, rm)) {

    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);

      if (!inf) {

        // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }

        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }

  external = true;

  return finalise(r, pr, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Estimate result exponent.
// x^y = 10^e,  where e = y * log10(x)
// log10(x) = log10(x_significand) + x_exponent
// log10(x_significand) = ln(x_significand) / ln(10)
k = mathpow(+x, yn);
e = k == 0 || !isFinite(k)
  ? mathfloor(yn * (Math.<span class="apidocCodeKeywordSpan">log</span>('0.' + digitsToString(x.d)) / Math.LN10 + x.e +
1))
  : new Ctor(k + '').e;

// Estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

// Overflow/underflow?
if (e &gt; Ctor.maxE + 1 || e &lt; Ctor.minE - 1) return new Ctor(e &gt; 0 ? sign / 0 : 0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.logarithm" id="apidoc.element.decimal.js.Decimal.prototype.logarithm">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>logarithm
        <span class="apidocSignatureSpan">(base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logarithm = function (base) {
  var isBase10, d, denominator, k, inf, num, sd, r,
    arg = this,
    Ctor = arg.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding,
    guard = 5;

  // Default base is 10.
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;

    // Return NaN if base is negative, or non-finite, or is 0 or 1.
    if (base.s &lt; 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

    isBase10 = base.eq(10);
  }

  d = arg.d;

  // Is arg negative, non-finite, 0 or 1?
  if (arg.s &lt; 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d &amp;&amp; !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }

  // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
  // integer power of 10.
  if (isBase10) {
    if (d.length &gt; 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0;) k /= 10;
      inf = k !== 1;
    }
  }

  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

  // The result will have 5 rounding digits.
  r = divide(num, denominator, sd, 1);

  // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
  // calculate 10 further digits.
  //
  // If the result is known to have an infinite decimal expansion, repeat this until it is clear
  // that the result is above or below the boundary. Otherwise, if after calculating the 10
  // further digits, the last 14 are nines, round up and assume the result is exact.
  // Also assume the result is exact if the last 14 are zero.
  //
  // Example of a result that will be incorrectly rounded:
  // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
  // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
  // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
  // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
  // place is still 2.6.
  if (checkRoundingDigits(r.d, k = pr, rm)) {

    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);

      if (!inf) {

        // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }

        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }

  external = true;

  return finalise(r, pr, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.lt" id="apidoc.element.decimal.js.Decimal.prototype.lt">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>lt
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lt = function (y) {
  return this.cmp(y) &lt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (maxD == null) {

  // d is 10**e, the minimum max-denominator needed.
  maxD = e &gt; 0 ? d : n1;
} else {
  n = new Ctor(maxD);
  if (!n.isInt() || n.<span class="apidocCodeKeywordSpan">lt</span>(n1)) throw Error(invalidArgument + n);
  maxD = n.gt(d) ? (e &gt; 0 ? d : n1) : n;
}

external = false;
n = new Ctor(digitsToString(xd));
pr = Ctor.precision;
Ctor.precision = e = xd.length * LOG_BASE * 2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.lte" id="apidoc.element.decimal.js.Decimal.prototype.lte">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>lte
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lte = function (y) {
  return this.cmp(y) &lt; 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   *
   */
  P.inverseHyperbolicCosine = P.acosh = function () {
var pr, rm,
  x = this,
  Ctor = x.constructor;

if (x.<span class="apidocCodeKeywordSpan">lte</span>(1)) return new Ctor(x.eq(1) ? 0 : NaN);
if (!x.isFinite()) return new Ctor(x);

pr = Ctor.precision;
rm = Ctor.rounding;
Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
Ctor.rounding = 1;
external = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.minus" id="apidoc.element.decimal.js.Decimal.prototype.minus">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>minus
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minus = function (y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // If either is not finite...
  if (!x.d || !y.d) {

    // Return NaN if either is NaN.
    if (!x.s || !y.s) y = new Ctor(NaN);

    // Return y negated if x is finite and y is Infinity.
    else if (x.d) y.s = -y.s;

    // Return x if y is finite and x is Infinity.
    // Return x if both are Infinity with different signs.
    // Return NaN if both are Infinity with the same sign.
    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

    return y;
  }

  // If signs differ...
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }

  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;

  // If either is zero...
  if (!xd[0] || !yd[0]) {

    // Return y negated if x is zero and y is non-zero.
    if (yd[0]) y.s = -y.s;

    // Return x if y is zero and x is non-zero.
    else if (xd[0]) y = new Ctor(x);

    // Return zero if both are zero.
    // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
    else return new Ctor(rm === 3 ? -0 : 0);

    return external ? finalise(y, pr, rm) : y;
  }

  // x and y are finite, non-zero numbers with the same sign.

  // Calculate base 1e7 exponents.
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);

  xd = xd.slice();
  k = xe - e;

  // If base 1e7 exponents differ...
  if (k) {
    xLTy = k &lt; 0;

    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }

    // Numbers with massively different exponents would result in a very high number of
    // zeros needing to be prepended, but this can be avoided while still ensuring correct
    // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

    if (k &gt; i) {
      k = i;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents.
    d.reverse();
    for (i = k; i--;) d.push(0);
    d.reverse();

  // Base 1e7 exponents equal.
  } else {

    // Check digits to determine which is the bigger number.

    i = xd.length;
    len = yd.length;
    xLTy = i &lt; len;
    if (xLTy) len = i;

    for (i = 0; i &lt; len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] &lt; yd[i];
        break;
      }
    }

    k = 0;
  }

  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }

  len = xd.length;

  // Append zeros to `xd` if shorter.
  // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
  for (i = yd.length - len; i &gt; 0; --i) xd[len++] = 0;

  // Subtract yd from xd.
  for (i = yd.length; i &gt; k;) {

    if (xd[--i] &lt; yd[i]) {
      for (j = i; j &amp;&amp; xd[--j] === 0;) xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }

    xd[i] -= yd[i];
  }

  // Remove trailing zeros.
  for (; xd[--len] === 0;) xd.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xd[0] === 0; xd.shift()) --e;

  // Zero?
  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

  y.d = xd;
  y.e = getBase10Exponent(xd, e);

  return external ? finalise(y, pr, rm) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A Decimal is immutable in the sense that it is not changed by its methods.

```js
0.3 - 0.1                     // 0.19999999999999998
x = new Decimal(0.3)
x.<span class="apidocCodeKeywordSpan">minus</span>(0.1)                  // '0.2'
x                             // '0.3'
```

The methods that return a Decimal can be chained.

```js
x.dividedBy(y).plus(z).times(9).floor()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.mod" id="apidoc.element.decimal.js.Decimal.prototype.mod">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>mod
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mod = function (y) {
  var q,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // Return NaN if x is Infinity or NaN, or y is NaN or 0.
  if (!x.d || !y.s || y.d &amp;&amp; !y.d[0]) return new Ctor(NaN);

  // Return x if y is Infinity or x is 0.
  if (!y.d || x.d &amp;&amp; !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }

  // Prevent rounding of intermediate calculations.
  external = false;

  if (Ctor.modulo == 9) {

    // Euclidian division: q = sign(y) * floor(x / abs(y))
    // result = x - q * y    where  0 &lt;= result &lt; abs(y)
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }

  q = q.times(y);

  external = true;

  return x.minus(q);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.<span class="apidocCodeKeywordSpan">mod</span>(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        //
true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
x.toExponential(5)              // '2.55500e+2'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.modulo" id="apidoc.element.decimal.js.Decimal.prototype.modulo">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>modulo
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">modulo = function (y) {
  var q,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // Return NaN if x is Infinity or NaN, or y is NaN or 0.
  if (!x.d || !y.s || y.d &amp;&amp; !y.d[0]) return new Ctor(NaN);

  // Return x if y is Infinity or x is 0.
  if (!y.d || x.d &amp;&amp; !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }

  // Prevent rounding of intermediate calculations.
  external = false;

  if (Ctor.modulo == 9) {

    // Euclidian division: q = sign(y) * floor(x / abs(y))
    // result = x - q * y    where  0 &lt;= result &lt; abs(y)
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }

  q = q.times(y);

  external = true;

  return x.minus(q);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.<span class="apidocCodeKeywordSpan">modulo</span>(z).negated()) == 1        //
true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
x.toExponential(5)              // '2.55500e+2'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.mul" id="apidoc.element.decimal.js.Decimal.prototype.mul">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>mul
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mul = function (y) {
  var carry, e, i, k, r, rL, t, xdL, ydL,
    x = this,
    Ctor = x.constructor,
    xd = x.d,
    yd = (y = new Ctor(y)).d;

  y.s *= x.s;

   // If either is NaN, Infinity or 0...
  if (!xd || !xd[0] || !yd || !yd[0]) {

    return new Ctor(!y.s || xd &amp;&amp; !xd[0] &amp;&amp; !yd || yd &amp;&amp; !yd[0] &amp;&amp; !xd

      // Return NaN if either is NaN.
      // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.
      ? NaN

      // Return Infinity if either is Infinity.
      // Return 0 if either is 0.
      : !xd || !yd ? y.s / 0 : y.s * 0);
  }

  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;

  // Ensure xd points to the longer array.
  if (xdL &lt; ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }

  // Initialise the result array with zeros.
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--;) r.push(0);

  // Multiply!
  for (i = ydL; --i &gt;= 0;) {
    carry = 0;
    for (k = xdL + i; k &gt; i;) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }

    r[k] = (r[k] + carry) % BASE | 0;
  }

  // Remove trailing zeros.
  for (; !r[--rL];) r.pop();

  if (carry) ++e;
  else r.shift();

  y.d = r;
  y.e = getBase10Exponent(r, e);

  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function mul(x, y) {
  return new this(x).<span class="apidocCodeKeywordSpan">mul</span>(y);
}


/*
 * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
 * significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.naturalExponential" id="apidoc.element.decimal.js.Decimal.prototype.naturalExponential">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>naturalExponential
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">naturalExponential = function () {
  return naturalExponential(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.naturalLogarithm" id="apidoc.element.decimal.js.Decimal.prototype.naturalLogarithm">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>naturalLogarithm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">naturalLogarithm = function () {
  return naturalLogarithm(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.neg" id="apidoc.element.decimal.js.Decimal.prototype.neg">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>neg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">neg = function () {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).<span class="apidocCodeKeywordSpan">neg</span>()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        //
true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
x.toExponential(5)              // '2.55500e+2'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.negated" id="apidoc.element.decimal.js.Decimal.prototype.negated">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>negated
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">negated = function () {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).<span class="apidocCodeKeywordSpan">negated</span>()) == 1        //
true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
x.toExponential(5)              // '2.55500e+2'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.plus" id="apidoc.element.decimal.js.Decimal.prototype.plus">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>plus
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plus = function (y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // If either is not finite...
  if (!x.d || !y.d) {

    // Return NaN if either is NaN.
    if (!x.s || !y.s) y = new Ctor(NaN);

    // Return x if y is finite and x is Infinity.
    // Return x if both are Infinity with the same sign.
    // Return NaN if both are Infinity with different signs.
    // Return y if x is finite and y is Infinity.
    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

    return y;
  }

   // If signs differ...
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }

  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;

  // If either is zero...
  if (!xd[0] || !yd[0]) {

    // Return x if y is zero.
    // Return y if y is non-zero.
    if (!yd[0]) y = new Ctor(x);

    return external ? finalise(y, pr, rm) : y;
  }

  // x and y are finite, non-zero numbers with the same sign.

  // Calculate base 1e7 exponents.
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);

  xd = xd.slice();
  i = k - e;

  // If base 1e7 exponents differ...
  if (i) {

    if (i &lt; 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }

    // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
    k = Math.ceil(pr / LOG_BASE);
    len = k &gt; len ? k + 1 : len + 1;

    if (i &gt; len) {
      i = len;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
    d.reverse();
    for (; i--;) d.push(0);
    d.reverse();
  }

  len = xd.length;
  i = yd.length;

  // If yd is longer than xd, swap xd and yd so xd points to the longer array.
  if (len - i &lt; 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }

  // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
  for (carry = 0; i;) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }

  if (carry) {
    xd.unshift(carry);
    ++e;
  }

  // Remove trailing zeros.
  // No need to check for zero, as +x + +y != 0 &amp;&amp; -x + -y != 0
  for (len = xd.length; xd[--len] == 0;) xd.pop();

  y.d = xd;
  y.e = getBase10Exponent(xd, e);

  return external ? finalise(y, pr, rm) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

A value can also be in binary, hexadecimal or octal if the appropriate prefix is included.

```js
x = new Decimal('0xff.f')            // '255.9375'
y = new Decimal('0b10101100')        // '172'
z = x.<span class="apidocCodeKeywordSpan">plus</span>(y)                        // '427.9375'

z.toBinary()                         // '0b110101011.1111'
z.toBinary(13)                       // '0b1.101010111111p+8'
```

A Decimal is immutable in the sense that it is not changed by its methods.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.pow" id="apidoc.element.decimal.js.Decimal.prototype.pow">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>pow
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pow = function (y) {
  var e, k, pr, r, rm, sign, yIsInt,
    x = this,
    Ctor = x.constructor,
    yn = +(y = new Ctor(y));

  // Either Infinity, NaN or 0?
  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return  new Ctor(mathpow(+x, yn));

  x = new Ctor(x);

  if (x.eq(1)) return x;

  pr = Ctor.precision;
  rm = Ctor.rounding;

  if (y.eq(1)) return finalise(x, pr, rm);

  e = mathfloor(y.e / LOG_BASE);
  k = y.d.length - 1;
  yIsInt = e &gt;= k;
  sign = x.s;

  if (!yIsInt) {
    if (sign &lt; 0) return new Ctor(NaN);

  // If y is a small integer use the 'exponentiation by squaring' algorithm.
  } else if ((k = yn &lt; 0 ? -yn : yn) &lt;= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s &lt; 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }

  // Result is negative if x is negative and the last digit of integer y is odd.
  sign = sign &lt; 0 &amp;&amp; y.d[Math.max(e, k)] &amp; 1 ? -1 : 1;

  // Estimate result exponent.
  // x^y = 10^e,  where e = y * log10(x)
  // log10(x) = log10(x_significand) + x_exponent
  // log10(x_significand) = ln(x_significand) / ln(10)
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k)
    ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
    : new Ctor(k + '').e;

  // Estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

  // Overflow/underflow?
  if (e &gt; Ctor.maxE + 1 || e &lt; Ctor.minE - 1) return new Ctor(e &gt; 0 ? sign / 0 : 0);

  external = false;
  Ctor.rounding = x.s = 1;

  // Estimate the extra guard digits needed to ensure five correct rounding digits from
  // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
  // new Decimal(2.32456).pow('2087987436534566.46411')
  // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
  k = Math.min(12, (e + '').length);

  // r = x^y = exp(y*ln(x))
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

  // Truncate to the required precision plus five rounding digits.
  r = finalise(r, pr + 5, 1);

  // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
  // the result.
  if (checkRoundingDigits(r.d, pr, rm)) {
    e = pr + 10;

    // Truncate to the increased precision plus five rounding digits.
    r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

    // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
    if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
      r = finalise(r, pr + 1, 0);
    }
  }

  r.s = sign;
  external = true;
  Ctor.rounding = rm;

  return finalise(r, pr, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).<span class="apidocCodeKeywordSpan">pow</span>(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.precision" id="apidoc.element.decimal.js.Decimal.prototype.precision">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>precision
        <span class="apidocSignatureSpan">(z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">precision = function (z) {
  var k,
    x = this;

  if (z !== void 0 &amp;&amp; z !== !!z &amp;&amp; z !== 1 &amp;&amp; z !== 0) throw Error(invalidArgument + z);

  if (x.d) {
    k = getPrecision(x.d);
    if (z &amp;&amp; x.e + 1 &gt; k) k = x.e + 1;
  } else {
    k = NaN;
  }

  return k;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.round" id="apidoc.element.decimal.js.Decimal.prototype.round">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>round
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">round = function () {
  var x = this,
    Ctor = x.constructor;

  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.sd" id="apidoc.element.decimal.js.Decimal.prototype.sd">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>sd
        <span class="apidocSignatureSpan">(z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sd = function (z) {
  var k,
    x = this;

  if (z !== void 0 &amp;&amp; z !== !!z &amp;&amp; z !== 1 &amp;&amp; z !== 0) throw Error(invalidArgument + z);

  if (x.d) {
    k = getPrecision(x.d);
    if (z &amp;&amp; x.e + 1 &gt; k) k = x.e + 1;
  } else {
    k = NaN;
  }

  return k;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!x.d) return new Ctor(NaN);

// cos(0) = cos(-0) = 1
if (!x.d[0]) return new Ctor(1);

pr = Ctor.precision;
rm = Ctor.rounding;
Ctor.precision = pr + Math.max(x.e, x.<span class="apidocCodeKeywordSpan">sd</span>()) + LOG_BASE;
Ctor.rounding = 1;

x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

Ctor.precision = pr;
Ctor.rounding = rm;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.sin" id="apidoc.element.decimal.js.Decimal.prototype.sin">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>sin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sin = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;

  x = sine(Ctor, toLessThanHalfPi(Ctor, x));

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant &gt; 2 ? x.neg() : x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (x.isZero()) return new Ctor(x);

pr = Ctor.precision;
rm = Ctor.rounding;
Ctor.precision = pr + 10;
Ctor.rounding = 1;

x = x.<span class="apidocCodeKeywordSpan">sin</span>();
x.s = 1;
x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

Ctor.precision = pr;
Ctor.rounding = rm;

return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.sine" id="apidoc.element.decimal.js.Decimal.prototype.sine">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>sine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sine = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;

  x = sine(Ctor, toLessThanHalfPi(Ctor, x));

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant &gt; 2 ? x.neg() : x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.sinh" id="apidoc.element.decimal.js.Decimal.prototype.sinh">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>sinh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sinh = function () {
  var k, pr, rm, len,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;

  if (len &lt; 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {

    // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
    // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
    // 3 multiplications and 1 addition

    // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
    // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
    // 4 multiplications and 2 additions

    // Estimate the optimum number of times to use the argument reduction.
    k = 1.4 * Math.sqrt(len);
    k = k &gt; 16 ? 16 : k | 0;

    x = x.times(Math.pow(5, -k));

    x = taylorSeries(Ctor, 2, x, x, true);

    // Reverse argument reduction
    var sinh2_x,
      d5 = new Ctor(5),
      d16 = new Ctor(16),
      d20 = new Ctor(20);
    for (; k--;) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;

  return divide(x.<span class="apidocCodeKeywordSpan">sinh</span>(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};


/*
 * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
 * this Decimal.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.sqrt" id="apidoc.element.decimal.js.Decimal.prototype.sqrt">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>sqrt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sqrt = function () {
  var m, n, sd, r, rep, t,
    x = this,
    d = x.d,
    e = x.e,
    s = x.s,
    Ctor = x.constructor;

  // Negative/NaN/Infinity/zero?
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s &lt; 0 &amp;&amp; (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }

  external = false;

  // Initial estimate.
  s = Math.sqrt(+x);

  // Math.sqrt underflow/overflow?
  // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);

    if ((n.length + e) % 2 == 0) n += '0';
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e &lt; 0 || e % 2);

    if (s == 1 / 0) {
      n = '1e' + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf('e') + 1) + e;
    }

    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }

  sd = (e = Ctor.precision) + 3;

  // Newton-Raphson iteration.
  for (;;) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);

    // TODO? Replace with for-loop and checkRoundingDigits.
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);

      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
      // 4999, i.e. approaching a rounding boundary, continue the iteration.
      if (n == '9999' || !rep &amp;&amp; n == '4999') {

        // On the first iteration only, check to see if rounding up gives the exact result as the
        // nines may infinitely repeat.
        if (!rep) {
          finalise(t, e + 1, 0);

          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }

        sd += 4;
        rep = 1;
      } else {

        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
        // If not, then there are further digits and m will be truthy.
        if (!+n || !+n.slice(1) &amp;&amp; n.charAt(0) == '5') {

          // Truncate to the first rounding digit.
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }

        break;
      }
    }
  }

  external = true;

  return finalise(r, e, Ctor.rounding, m);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.<span class="apidocCodeKeywordSpan">sqrt</span>().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.squareRoot" id="apidoc.element.decimal.js.Decimal.prototype.squareRoot">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>squareRoot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">squareRoot = function () {
  var m, n, sd, r, rep, t,
    x = this,
    d = x.d,
    e = x.e,
    s = x.s,
    Ctor = x.constructor;

  // Negative/NaN/Infinity/zero?
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s &lt; 0 &amp;&amp; (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }

  external = false;

  // Initial estimate.
  s = Math.sqrt(+x);

  // Math.sqrt underflow/overflow?
  // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);

    if ((n.length + e) % 2 == 0) n += '0';
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e &lt; 0 || e % 2);

    if (s == 1 / 0) {
      n = '1e' + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf('e') + 1) + e;
    }

    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }

  sd = (e = Ctor.precision) + 3;

  // Newton-Raphson iteration.
  for (;;) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);

    // TODO? Replace with for-loop and checkRoundingDigits.
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);

      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
      // 4999, i.e. approaching a rounding boundary, continue the iteration.
      if (n == '9999' || !rep &amp;&amp; n == '4999') {

        // On the first iteration only, check to see if rounding up gives the exact result as the
        // nines may infinitely repeat.
        if (!rep) {
          finalise(t, e + 1, 0);

          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }

        sd += 4;
        rep = 1;
      } else {

        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
        // If not, then there are further digits and m will be truthy.
        if (!+n || !+n.slice(1) &amp;&amp; n.charAt(0) == '5') {

          // Truncate to the first rounding digit.
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }

        break;
      }
    }
  }

  external = true;

  return finalise(r, e, Ctor.rounding, m);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.<span class="apidocCodeKeywordSpan">squareRoot</span>().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.sub" id="apidoc.element.decimal.js.Decimal.prototype.sub">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>sub
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sub = function (y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // If either is not finite...
  if (!x.d || !y.d) {

    // Return NaN if either is NaN.
    if (!x.s || !y.s) y = new Ctor(NaN);

    // Return y negated if x is finite and y is Infinity.
    else if (x.d) y.s = -y.s;

    // Return x if y is finite and x is Infinity.
    // Return x if both are Infinity with different signs.
    // Return NaN if both are Infinity with the same sign.
    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

    return y;
  }

  // If signs differ...
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }

  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;

  // If either is zero...
  if (!xd[0] || !yd[0]) {

    // Return y negated if x is zero and y is non-zero.
    if (yd[0]) y.s = -y.s;

    // Return x if y is zero and x is non-zero.
    else if (xd[0]) y = new Ctor(x);

    // Return zero if both are zero.
    // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
    else return new Ctor(rm === 3 ? -0 : 0);

    return external ? finalise(y, pr, rm) : y;
  }

  // x and y are finite, non-zero numbers with the same sign.

  // Calculate base 1e7 exponents.
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);

  xd = xd.slice();
  k = xe - e;

  // If base 1e7 exponents differ...
  if (k) {
    xLTy = k &lt; 0;

    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }

    // Numbers with massively different exponents would result in a very high number of
    // zeros needing to be prepended, but this can be avoided while still ensuring correct
    // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

    if (k &gt; i) {
      k = i;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents.
    d.reverse();
    for (i = k; i--;) d.push(0);
    d.reverse();

  // Base 1e7 exponents equal.
  } else {

    // Check digits to determine which is the bigger number.

    i = xd.length;
    len = yd.length;
    xLTy = i &lt; len;
    if (xLTy) len = i;

    for (i = 0; i &lt; len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] &lt; yd[i];
        break;
      }
    }

    k = 0;
  }

  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }

  len = xd.length;

  // Append zeros to `xd` if shorter.
  // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
  for (i = yd.length - len; i &gt; 0; --i) xd[len++] = 0;

  // Subtract yd from xd.
  for (i = yd.length; i &gt; k;) {

    if (xd[--i] &lt; yd[i]) {
      for (j = i; j &amp;&amp; xd[--j] === 0;) xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }

    xd[i] -= yd[i];
  }

  // Remove trailing zeros.
  for (; xd[--len] === 0;) xd.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xd[0] === 0; xd.shift()) --e;

  // Zero?
  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

  y.d = xd;
  y.e = getBase10Exponent(xd, e);

  return external ? finalise(y, pr, rm) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function sub(x, y) {
  return new this(x).<span class="apidocCodeKeywordSpan">sub</span>(y);
}


/*
 * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.tan" id="apidoc.element.decimal.js.Decimal.prototype.tan">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>tan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tan = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;

  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function tan(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">tan</span>();
}


/*
 * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.tangent" id="apidoc.element.decimal.js.Decimal.prototype.tangent">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>tangent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tangent = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;

  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.tanh" id="apidoc.element.decimal.js.Decimal.prototype.tanh">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>tanh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tanh = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(x.s);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;

  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function tanh(x) {
  return new this(x).<span class="apidocCodeKeywordSpan">tanh</span>();
}


/*
 * Return a new Decimal whose value is `x` truncated to an integer.
 *
 * x {number|string|Decimal}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.times" id="apidoc.element.decimal.js.Decimal.prototype.times">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>times
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">times = function (y) {
  var carry, e, i, k, r, rL, t, xdL, ydL,
    x = this,
    Ctor = x.constructor,
    xd = x.d,
    yd = (y = new Ctor(y)).d;

  y.s *= x.s;

   // If either is NaN, Infinity or 0...
  if (!xd || !xd[0] || !yd || !yd[0]) {

    return new Ctor(!y.s || xd &amp;&amp; !xd[0] &amp;&amp; !yd || yd &amp;&amp; !yd[0] &amp;&amp; !xd

      // Return NaN if either is NaN.
      // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.
      ? NaN

      // Return Infinity if either is Infinity.
      // Return 0 if either is 0.
      : !xd || !yd ? y.s / 0 : y.s * 0);
  }

  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;

  // Ensure xd points to the longer array.
  if (xdL &lt; ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }

  // Initialise the result array with zeros.
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--;) r.push(0);

  // Multiply!
  for (i = ydL; --i &gt;= 0;) {
    carry = 0;
    for (k = xdL + i; k &gt; i;) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }

    r[k] = (r[k] + carry) % BASE | 0;
  }

  // Remove trailing zeros.
  for (; !r[--rL];) r.pop();

  if (carry) ++e;
  else r.shift();

  y.d = r;
  y.e = getBase10Exponent(r, e);

  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.minus(0.1)                  // '0.2'
x                             // '0.3'
```

The methods that return a Decimal can be chained.

```js
x.dividedBy(y).plus(z).<span class="apidocCodeKeywordSpan">times</span>(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).toPower(3).equals(x.sqrt().div(y).pow(3))         // true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toBinary" id="apidoc.element.decimal.js.Decimal.prototype.toBinary">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toBinary
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBinary = function (sd, rm) {
  return toStringBinary(this, 2, sd, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
A value can also be in binary, hexadecimal or octal if the appropriate prefix is included.

```js
x = new Decimal('0xff.f')            // '255.9375'
y = new Decimal('0b10101100')        // '172'
z = x.plus(y)                        // '427.9375'

z.<span class="apidocCodeKeywordSpan">toBinary</span>()                         // '0b110101011.1111'
z.toBinary(13)                       // '0b1.101010111111p+8'
```

A Decimal is immutable in the sense that it is not changed by its methods.

```js
0.3 - 0.1                     // 0.19999999999999998
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toDP" id="apidoc.element.decimal.js.Decimal.prototype.toDP">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toDP
        <span class="apidocSignatureSpan">(dp, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toDP = function (dp, rm) {
  var x = this,
    Ctor = x.constructor;

  x = new Ctor(x);
  if (dp === void 0) return x;

  checkInt32(dp, 0, MAX_DIGITS);

  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);

  return finalise(x, dp + x.e + 1, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toDecimalPlaces" id="apidoc.element.decimal.js.Decimal.prototype.toDecimalPlaces">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toDecimalPlaces
        <span class="apidocSignatureSpan">(dp, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toDecimalPlaces = function (dp, rm) {
  var x = this,
    Ctor = x.constructor;

  x = new Ctor(x);
  if (dp === void 0) return x;

  checkInt32(dp, 0, MAX_DIGITS);

  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);

  return finalise(x, dp + x.e + 1, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toExponential" id="apidoc.element.decimal.js.Decimal.prototype.toExponential">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toExponential
        <span class="apidocSignatureSpan">(dp, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toExponential = function (dp, rm) {
  var str,
    x = this,
    Ctor = x.constructor;

  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }

  return x.isNeg() &amp;&amp; !x.isZero() ? '-' + str : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
x.<span class="apidocCodeKeywordSpan">toExponential</span>(5)              // '2.55500e+2'
x.toFixed(5)                    // '255.50000'
x.toPrecision(5)                // '255.50'
```

and almost all of the methods of JavaScript's Math object are also replicated.

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toFixed" id="apidoc.element.decimal.js.Decimal.prototype.toFixed">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toFixed
        <span class="apidocSignatureSpan">(dp, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toFixed = function (dp, rm) {
  var str, y,
    x = this,
    Ctor = x.constructor;

  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }

  // To determine whether to add the minus sign look at the value before it was rounded,
  // i.e. look at `x` rather than `y`.
  return x.isNeg() &amp;&amp; !x.isZero() ? '-' + str : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
x.toExponential(5)              // '2.55500e+2'
x.<span class="apidocCodeKeywordSpan">toFixed</span>(5)                    // '255.50000'
x.toPrecision(5)                // '255.50'
```

and almost all of the methods of JavaScript's Math object are also replicated.

```js
Decimal.sqrt('6.98372465832e+9823')      // '8.3568682281821340204e+4911'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toFraction" id="apidoc.element.decimal.js.Decimal.prototype.toFraction">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toFraction
        <span class="apidocSignatureSpan">(maxD)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toFraction = function (maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
    x = this,
    xd = x.d,
    Ctor = x.constructor;

  if (!xd) return new Ctor(x);

  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);

  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k &lt; 0 ? LOG_BASE + k : k);

  if (maxD == null) {

    // d is 10**e, the minimum max-denominator needed.
    maxD = e &gt; 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
    maxD = n.gt(d) ? (e &gt; 0 ? d : n1) : n;
  }

  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;

  for (;;)  {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1) break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }

  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;

  // Determine which fraction is closer to x, n0/d0 or n1/d1?
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) &lt; 1
      ? [n1, d1] : [n0, d0];

  Ctor.precision = pr;
  external = true;

  return r;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

and a `toFraction` method with an optional *maximum denominator* argument

```js
z = new Decimal(355)
pi = z.dividedBy(113)        // '3.1415929204'
pi.<span class="apidocCodeKeywordSpan">toFraction</span>()              // [ '7853982301', '2500000000' ]
pi.toFraction(1000)          // [ '355', '113' ]
```

All calculations are rounded according to the number of significant digits and rounding mode
specified by the `precision` and `rounding` properties of the Decimal constructor.

Multiple Decimal constructors can be created, each with their own independent configuration which
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toHex" id="apidoc.element.decimal.js.Decimal.prototype.toHex">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toHex
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHex = function (sd, rm) {
  return toStringBinary(this, 16, sd, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toHexadecimal" id="apidoc.element.decimal.js.Decimal.prototype.toHexadecimal">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toHexadecimal
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHexadecimal = function (sd, rm) {
  return toStringBinary(this, 16, sd, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toJSON" id="apidoc.element.decimal.js.Decimal.prototype.toJSON">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var x = this,
    Ctor = x.constructor,
    str = finiteToString(x, x.e &lt;= Ctor.toExpNeg || x.e &gt;= Ctor.toExpPos);

  return x.isNeg() ? '-' + str : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toNearest" id="apidoc.element.decimal.js.Decimal.prototype.toNearest">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toNearest
        <span class="apidocSignatureSpan">(y, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNearest = function (y, rm) {
  var x = this,
    Ctor = x.constructor;

  x = new Ctor(x);

  if (y == null) {

    // If x is not finite, return x.
    if (!x.d) return x;

    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm !== void 0) checkInt32(rm, 0, 8);

    // If x is not finite, return x if y is not NaN, else NaN.
    if (!x.d) return y.s ? x : y;

    // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
    if (!y.d) {
      if (y.s) y.s = x.s;
      return y;
    }
  }

  // If y is not zero, calculate the nearest multiple of y to x.
  if (y.d[0]) {
    external = false;
    if (rm &lt; 4) rm = [4, 5, 7, 8][rm];
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);

  // If y is zero, return zero with the sign of x.
  } else {
    y.s = x.s;
    x = y;
  }

  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toNumber" id="apidoc.element.decimal.js.Decimal.prototype.toNumber">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toNumber
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toNumber = function () {
  return +this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toOctal" id="apidoc.element.decimal.js.Decimal.prototype.toOctal">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toOctal
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toOctal = function (sd, rm) {
  return toStringBinary(this, 8, sd, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toPower" id="apidoc.element.decimal.js.Decimal.prototype.toPower">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toPower
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPower = function (y) {
  var e, k, pr, r, rm, sign, yIsInt,
    x = this,
    Ctor = x.constructor,
    yn = +(y = new Ctor(y));

  // Either Infinity, NaN or 0?
  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return  new Ctor(mathpow(+x, yn));

  x = new Ctor(x);

  if (x.eq(1)) return x;

  pr = Ctor.precision;
  rm = Ctor.rounding;

  if (y.eq(1)) return finalise(x, pr, rm);

  e = mathfloor(y.e / LOG_BASE);
  k = y.d.length - 1;
  yIsInt = e &gt;= k;
  sign = x.s;

  if (!yIsInt) {
    if (sign &lt; 0) return new Ctor(NaN);

  // If y is a small integer use the 'exponentiation by squaring' algorithm.
  } else if ((k = yn &lt; 0 ? -yn : yn) &lt;= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s &lt; 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }

  // Result is negative if x is negative and the last digit of integer y is odd.
  sign = sign &lt; 0 &amp;&amp; y.d[Math.max(e, k)] &amp; 1 ? -1 : 1;

  // Estimate result exponent.
  // x^y = 10^e,  where e = y * log10(x)
  // log10(x) = log10(x_significand) + x_exponent
  // log10(x_significand) = ln(x_significand) / ln(10)
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k)
    ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
    : new Ctor(k + '').e;

  // Estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

  // Overflow/underflow?
  if (e &gt; Ctor.maxE + 1 || e &lt; Ctor.minE - 1) return new Ctor(e &gt; 0 ? sign / 0 : 0);

  external = false;
  Ctor.rounding = x.s = 1;

  // Estimate the extra guard digits needed to ensure five correct rounding digits from
  // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
  // new Decimal(2.32456).pow('2087987436534566.46411')
  // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
  k = Math.min(12, (e + '').length);

  // r = x^y = exp(y*ln(x))
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

  // Truncate to the required precision plus five rounding digits.
  r = finalise(r, pr + 5, 1);

  // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
  // the result.
  if (checkRoundingDigits(r.d, pr, rm)) {
    e = pr + 10;

    // Truncate to the increased precision plus five rounding digits.
    r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

    // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
    if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
      r = finalise(r, pr + 1, 0);
    }
  }

  r.s = sign;
  external = true;
  Ctor.rounding = rm;

  return finalise(r, pr, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
x.dividedBy(y).plus(z).times(9).floor()
x.times('1.23456780123456789e+9').plus(9876.5432321).dividedBy('4444562598.111772').ceil()
```

Many method names have a shorter alias.

```js
x.squareRoot().dividedBy(y).<span class="apidocCodeKeywordSpan">toPower</span>(3).equals(x.sqrt().div(y).pow(3))         // true
x.cmp(y.mod(z).neg()) == 1 &amp;&amp; x.comparedTo(y.modulo(z).negated()) == 1        // true
```

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toPrecision" id="apidoc.element.decimal.js.Decimal.prototype.toPrecision">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toPrecision
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPrecision = function (sd, rm) {
  var str,
    x = this,
    Ctor = x.constructor;

  if (sd === void 0) {
    str = finiteToString(x, x.e &lt;= Ctor.toExpNeg || x.e &gt;= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd &lt;= x.e || x.e &lt;= Ctor.toExpNeg, sd);
  }

  return x.isNeg() &amp;&amp; !x.isZero() ? '-' + str : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Like JavaScript's Number type, there are `toExponential`, `toFixed` and `toPrecision` methods,

```js
x = new Decimal(255.5)
x.toExponential(5)              // '2.55500e+2'
x.toFixed(5)                    // '255.50000'
x.<span class="apidocCodeKeywordSpan">toPrecision</span>(5)                // '255.50'
```

and almost all of the methods of JavaScript's Math object are also replicated.

```js
Decimal.sqrt('6.98372465832e+9823')      // '8.3568682281821340204e+4911'
Decimal.pow(2, 0.0979843)                // '1.0702770511687781839'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toSD" id="apidoc.element.decimal.js.Decimal.prototype.toSD">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toSD
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSD = function (sd, rm) {
  var x = this,
    Ctor = x.constructor;

  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }

  return finalise(new Ctor(x), sd, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toSignificantDigits" id="apidoc.element.decimal.js.Decimal.prototype.toSignificantDigits">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toSignificantDigits
        <span class="apidocSignatureSpan">(sd, rm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSignificantDigits = function (sd, rm) {
  var x = this,
    Ctor = x.constructor;

  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }

  return finalise(new Ctor(x), sd, rm);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.toString" id="apidoc.element.decimal.js.Decimal.prototype.toString">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  var x = this,
    Ctor = x.constructor,
    str = finiteToString(x, x.e &lt;= Ctor.toExpNeg || x.e &gt;= Ctor.toExpPos);

  return x.isNeg() &amp;&amp; !x.isZero() ? '-' + str : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    n = s.toExponential();
    n = n.slice(0, n.indexOf('e') + 1) + e;
  }

  r = new Ctor(n);
  r.s = x.s;
} else {
  r = new Ctor(s.<span class="apidocCodeKeywordSpan">toString</span>());
}

sd = (e = Ctor.precision) + 3;

// Halley's method.
// TODO? Compare Newton's method.
for (;;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.trunc" id="apidoc.element.decimal.js.Decimal.prototype.trunc">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>trunc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trunc = function () {
  return finalise(new this.constructor(this), this.e + 1, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.truncated" id="apidoc.element.decimal.js.Decimal.prototype.truncated">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>truncated
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncated = function () {
  return finalise(new this.constructor(this), this.e + 1, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.decimal.js.Decimal.prototype.valueOf" id="apidoc.element.decimal.js.Decimal.prototype.valueOf">
        function <span class="apidocSignatureSpan">decimal.js.Decimal.prototype.</span>valueOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">valueOf = function () {
  var x = this,
    Ctor = x.constructor,
    str = finiteToString(x, x.e &lt;= Ctor.toExpNeg || x.e &gt;= Ctor.toExpPos);

  return x.isNeg() ? '-' + str : str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>